/* tslint:disable */
/* eslint-disable */
/**
 * CVAT REST API
 * REST API for Computer Vision Annotation Tool (CVAT)
 *
 * The version of the OpenAPI document: 2.30.0
 * Contact: support@cvat.ai
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { AnnotationsRead } from '../models';
// @ts-ignore
import type { DataMetaRead } from '../models';
// @ts-ignore
import type { DataRequest } from '../models';
// @ts-ignore
import type { DataResponse } from '../models';
// @ts-ignore
import type { LabeledData } from '../models';
// @ts-ignore
import type { PaginatedTaskReadList } from '../models';
// @ts-ignore
import type { PatchedDataMetaWriteRequest } from '../models';
// @ts-ignore
import type { PatchedLabeledDataRequest } from '../models';
// @ts-ignore
import type { PatchedTaskValidationLayoutWriteRequest } from '../models';
// @ts-ignore
import type { PatchedTaskWriteRequest } from '../models';
// @ts-ignore
import type { RqId } from '../models';
// @ts-ignore
import type { RqStatus } from '../models';
// @ts-ignore
import type { TaskAnnotationsUpdateRequest } from '../models';
// @ts-ignore
import type { TaskAnnotationsWriteRequest } from '../models';
// @ts-ignore
import type { TaskFileRequest } from '../models';
// @ts-ignore
import type { TaskRead } from '../models';
// @ts-ignore
import type { TaskValidationLayoutRead } from '../models';
// @ts-ignore
import type { TaskWriteRequest } from '../models';
/**
 * TasksApi - axios parameter creator
 * @export
 */
export const TasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The new task will not have any attached images or videos. To attach them, use the /api/tasks/<id>/data endpoint. 
         * @summary Create a task
         * @param {TaskWriteRequest} taskWriteRequest 
         * @param {string} [xOrganization] Organization unique slug
         * @param {string} [org] Organization unique slug
         * @param {number} [orgId] Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksCreate: async (taskWriteRequest: TaskWriteRequest, xOrganization?: string, org?: string, orgId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskWriteRequest' is not null or undefined
            assertParamExists('tasksCreate', 'taskWriteRequest', taskWriteRequest)
            const localVarPath = `/api/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['org_id'] = orgId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xOrganization != null) {
                localVarHeaderParameter['X-Organization'] = String(xOrganization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taskWriteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  The request POST /api/tasks/id/annotations will initiate the import and will create the rq job on the server in which the import will be carried out. Please, use the PUT /api/tasks/id/annotations endpoint for checking status of the process. 
         * @summary Import annotations into a task
         * @param {number} id A unique integer value identifying this task.
         * @param {number} [cloudStorageId] Storage id
         * @param {string} [filename] Annotation file name
         * @param {string} [format] Input format name You can get the list of supported formats at: /server/annotation/formats
         * @param {TasksCreateAnnotationsLocationEnum} [location] where to import the annotation from
         * @param {boolean} [useDefaultLocation] Use the location that was configured in task to import annotations
         * @param {TaskAnnotationsWriteRequest | null} [taskAnnotationsWriteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksCreateAnnotations: async (id: number, cloudStorageId?: number, filename?: string, format?: string, location?: TasksCreateAnnotationsLocationEnum, useDefaultLocation?: boolean, taskAnnotationsWriteRequest?: TaskAnnotationsWriteRequest | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksCreateAnnotations', 'id', id)
            const localVarPath = `/api/tasks/{id}/annotations/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required

            if (cloudStorageId !== undefined) {
                localVarQueryParameter['cloud_storage_id'] = cloudStorageId;
            }

            if (filename !== undefined) {
                localVarQueryParameter['filename'] = filename;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }

            if (useDefaultLocation !== undefined) {
                localVarQueryParameter['use_default_location'] = useDefaultLocation;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taskAnnotationsWriteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  The backup import process is as follows:  The first request POST /api/tasks/backup will initiate file upload and will create the rq job on the server in which the process of a task creating from an uploaded backup will be carried out.  After initiating the backup upload, you will receive an rq_id parameter. Make sure to include this parameter as a query parameter in your subsequent requests to track the status of the task creation. Once the task has been successfully created, the server will return the id of the newly created task. 
         * @summary Recreate a task from a backup
         * @param {string} [xOrganization] Organization unique slug
         * @param {number} [cloudStorageId] Storage id
         * @param {string} [filename] Backup file name
         * @param {TasksCreateBackupLocationEnum} [location] Where to import the backup file from
         * @param {string} [org] Organization unique slug
         * @param {number} [orgId] Organization identifier
         * @param {string} [rqId] rq id
         * @param {TaskFileRequest} [taskFileRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksCreateBackup: async (xOrganization?: string, cloudStorageId?: number, filename?: string, location?: TasksCreateBackupLocationEnum, org?: string, orgId?: number, rqId?: string, taskFileRequest?: TaskFileRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tasks/backup/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required

            if (cloudStorageId !== undefined) {
                localVarQueryParameter['cloud_storage_id'] = cloudStorageId;
            }

            if (filename !== undefined) {
                localVarQueryParameter['filename'] = filename;
            }

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['org_id'] = orgId;
            }

            if (rqId !== undefined) {
                localVarQueryParameter['rq_id'] = rqId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xOrganization != null) {
                localVarHeaderParameter['X-Organization'] = String(xOrganization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taskFileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The request `POST /api/<projects|tasks>/id/backup/export` will initialize a background process to backup a resource. To check status of the process please, use `GET /api/requests/<rq_id>` where **rq_id** is request ID returned in the response for this endpoint. 
         * @summary Initiate process to backup resource
         * @param {number} id A unique integer value identifying this task.
         * @param {number} [cloudStorageId] Storage id
         * @param {string} [filename] Backup file name
         * @param {TasksCreateBackupExportLocationEnum} [location] Where need to save downloaded backup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksCreateBackupExport: async (id: number, cloudStorageId?: number, filename?: string, location?: TasksCreateBackupExportLocationEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksCreateBackupExport', 'id', id)
            const localVarPath = `/api/tasks/{id}/backup/export`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required

            if (cloudStorageId !== undefined) {
                localVarQueryParameter['cloud_storage_id'] = cloudStorageId;
            }

            if (filename !== undefined) {
                localVarQueryParameter['filename'] = filename;
            }

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows to upload data (images, video, etc.) to a task. Supports the TUS open file uploading protocol (https://tus.io/).  Supports the following protocols:  1. A single Data request  and  2.1. An Upload-Start request 2.2.a. Regular TUS protocol requests (Upload-Length + Chunks) 2.2.b. Upload-Multiple requests 2.3. An Upload-Finish request  Requests: - Data - POST, no extra headers or \'Upload-Start\' + \'Upload-Finish\' headers.   Contains data in the body. - Upload-Start - POST, has an \'Upload-Start\' header. No body is expected. - Upload-Length - POST, has an \'Upload-Length\' header (see the TUS specification) - Chunk - HEAD/PATCH (see the TUS specification). Sent to /data/<file id> endpoints. - Upload-Finish - POST, has an \'Upload-Finish\' header. Can contain data in the body. - Upload-Multiple - POST, has an \'Upload-Multiple\' header. Contains data in the body.  The \'Upload-Finish\' request allows to specify the uploaded files should be ordered. This may be needed if the files can be sent unordered. To state that the input files are sent ordered, pass an empty list of files in the \'upload_file_order\' field. If the files are sent unordered, the ordered file list is expected in the \'upload_file_order\' field. It must be a list of string file paths, relative to the dataset root.  Example: files = [     \"cats/cat_1.jpg\",     \"dogs/dog2.jpg\",     \"image_3.png\",     ... ]  Independently of the file declaration field used (\'client_files\', \'server_files\', etc.), when the \'predefined\' sorting method is selected, the uploaded files will be ordered according to the \'.jsonl\' manifest file, if it is found in the list of files. For archives (e.g. \'.zip\'), a manifest file (\'*.jsonl\') is required when using the \'predefined\' file ordering. Such file must be provided next to the archive in the list of files. Read more about manifest files here: https://docs.cvat.ai/docs/manual/advanced/dataset_manifest/  After all data is sent, the operation status can be retrieved via the `GET /api/requests/<rq_id>`, where **rq_id** is request ID returned for this request.  Once data is attached to a task, it cannot be detached or replaced. 
         * @summary Attach data to a task
         * @param {number} id A unique integer value identifying this task.
         * @param {boolean} [uploadFinish] Finishes data upload. Can be combined with Upload-Start header to create task data with one request
         * @param {boolean} [uploadMultiple] Indicates that data with this request are single or multiple files that should be attached to a task
         * @param {boolean} [uploadStart] Initializes data upload. Optionally, can include upload metadata in the request body.
         * @param {DataRequest} [dataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksCreateData: async (id: number, uploadFinish?: boolean, uploadMultiple?: boolean, uploadStart?: boolean, dataRequest?: DataRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksCreateData', 'id', id)
            const localVarPath = `/api/tasks/{id}/data/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (uploadFinish != null) {
                localVarHeaderParameter['Upload-Finish'] = typeof uploadFinish === 'string'
                    ? uploadFinish
                    : JSON.stringify(uploadFinish);
            }
            if (uploadMultiple != null) {
                localVarHeaderParameter['Upload-Multiple'] = typeof uploadMultiple === 'string'
                    ? uploadMultiple
                    : JSON.stringify(uploadMultiple);
            }
            if (uploadStart != null) {
                localVarHeaderParameter['Upload-Start'] = typeof uploadStart === 'string'
                    ? uploadStart
                    : JSON.stringify(uploadStart);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The request `POST /api/<projects|tasks|jobs>/id/dataset/export` will initialize a background process to export a dataset. To check status of the process please, use `GET /api/requests/<rq_id>` where **rq_id** is request ID returned in the response for this endpoint. 
         * @summary Initialize process to export resource as a dataset in a specific format
         * @param {string} format Desired output format name You can get the list of supported formats at: /server/annotation/formats
         * @param {number} id A unique integer value identifying this task.
         * @param {number} [cloudStorageId] Storage id
         * @param {string} [filename] Desired output file name
         * @param {TasksCreateDatasetExportLocationEnum} [location] Where need to save downloaded dataset
         * @param {boolean} [saveImages] Include images or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksCreateDatasetExport: async (format: string, id: number, cloudStorageId?: number, filename?: string, location?: TasksCreateDatasetExportLocationEnum, saveImages?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'format' is not null or undefined
            assertParamExists('tasksCreateDatasetExport', 'format', format)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksCreateDatasetExport', 'id', id)
            const localVarPath = `/api/tasks/{id}/dataset/export`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required

            if (cloudStorageId !== undefined) {
                localVarQueryParameter['cloud_storage_id'] = cloudStorageId;
            }

            if (filename !== undefined) {
                localVarQueryParameter['filename'] = filename;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }

            if (saveImages !== undefined) {
                localVarQueryParameter['save_images'] = saveImages;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * All attached jobs, annotations and data will be deleted as well.
         * @summary Delete a task
         * @param {number} id A unique integer value identifying this task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksDestroy', 'id', id)
            const localVarPath = `/api/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete task annotations
         * @param {number} id A unique integer value identifying this task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksDestroyAnnotations: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksDestroyAnnotations', 'id', id)
            const localVarPath = `/api/tasks/{id}/annotations/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List tasks
         * @param {string} [xOrganization] Organization unique slug
         * @param {string} [assignee] A simple equality filter for the assignee field
         * @param {TasksListDimensionEnum} [dimension] A simple equality filter for the dimension field
         * @param {string} [filter]  JSON Logic filter. This filter can be used to perform complex filtering by grouping rules.  For example, using such a filter you can get all resources created by you:      - {\&quot;and\&quot;:[{\&quot;&#x3D;&#x3D;\&quot;:[{\&quot;var\&quot;:\&quot;owner\&quot;},\&quot;&lt;user&gt;\&quot;]}]}  Details about the syntax used can be found at the link: https://jsonlogic.com/   Available filter_fields: [\&#39;project_name\&#39;, \&#39;name\&#39;, \&#39;owner\&#39;, \&#39;status\&#39;, \&#39;assignee\&#39;, \&#39;subset\&#39;, \&#39;mode\&#39;, \&#39;dimension\&#39;, \&#39;tracker_link\&#39;, \&#39;validation_mode\&#39;, \&#39;id\&#39;, \&#39;project_id\&#39;, \&#39;updated_date\&#39;].  There are few examples for complex filtering tasks:      - Get all tasks from 1,2,3 projects - { \&quot;and\&quot; : [{ \&quot;in\&quot; : [{ \&quot;var\&quot; : \&quot;project_id\&quot; }, [1, 2, 3]]}]}      - Get all completed tasks from 1 project - { \&quot;and\&quot;: [{ \&quot;&#x3D;&#x3D;\&quot;: [{ \&quot;var\&quot; : \&quot;status\&quot; }, \&quot;completed\&quot;]}, { \&quot;&#x3D;&#x3D;\&quot; : [{ \&quot;var\&quot; : \&quot;project_id\&quot;}, 1]}]}  
         * @param {string} [mode] A simple equality filter for the mode field
         * @param {string} [name] A simple equality filter for the name field
         * @param {string} [org] Organization unique slug
         * @param {number} [orgId] Organization identifier
         * @param {string} [owner] A simple equality filter for the owner field
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [projectId] A simple equality filter for the project_id field
         * @param {string} [projectName] A simple equality filter for the project_name field
         * @param {string} [search] A search term. Available search_fields: (\&#39;project_name\&#39;, \&#39;name\&#39;, \&#39;owner\&#39;, \&#39;status\&#39;, \&#39;assignee\&#39;, \&#39;subset\&#39;, \&#39;mode\&#39;, \&#39;dimension\&#39;, \&#39;tracker_link\&#39;, \&#39;validation_mode\&#39;)
         * @param {string} [sort] Which field to use when ordering the results. Available ordering_fields: [\&#39;project_name\&#39;, \&#39;name\&#39;, \&#39;owner\&#39;, \&#39;status\&#39;, \&#39;assignee\&#39;, \&#39;subset\&#39;, \&#39;mode\&#39;, \&#39;dimension\&#39;, \&#39;tracker_link\&#39;, \&#39;validation_mode\&#39;, \&#39;id\&#39;, \&#39;project_id\&#39;, \&#39;updated_date\&#39;]
         * @param {TasksListStatusEnum} [status] A simple equality filter for the status field
         * @param {string} [subset] A simple equality filter for the subset field
         * @param {string} [trackerLink] A simple equality filter for the tracker_link field
         * @param {TasksListValidationModeEnum} [validationMode] A simple equality filter for the validation_mode field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksList: async (xOrganization?: string, assignee?: string, dimension?: TasksListDimensionEnum, filter?: string, mode?: string, name?: string, org?: string, orgId?: number, owner?: string, page?: number, pageSize?: number, projectId?: number, projectName?: string, search?: string, sort?: string, status?: TasksListStatusEnum, subset?: string, trackerLink?: string, validationMode?: TasksListValidationModeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required

            if (assignee !== undefined) {
                localVarQueryParameter['assignee'] = assignee;
            }

            if (dimension !== undefined) {
                localVarQueryParameter['dimension'] = dimension;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['org_id'] = orgId;
            }

            if (owner !== undefined) {
                localVarQueryParameter['owner'] = owner;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (projectName !== undefined) {
                localVarQueryParameter['project_name'] = projectName;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (subset !== undefined) {
                localVarQueryParameter['subset'] = subset;
            }

            if (trackerLink !== undefined) {
                localVarQueryParameter['tracker_link'] = trackerLink;
            }

            if (validationMode !== undefined) {
                localVarQueryParameter['validation_mode'] = validationMode;
            }


    
            if (xOrganization != null) {
                localVarHeaderParameter['X-Organization'] = String(xOrganization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a task
         * @param {number} id A unique integer value identifying this task.
         * @param {PatchedTaskWriteRequest} [patchedTaskWriteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksPartialUpdate: async (id: number, patchedTaskWriteRequest?: PatchedTaskWriteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksPartialUpdate', 'id', id)
            const localVarPath = `/api/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedTaskWriteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update task annotations
         * @param {TasksPartialUpdateAnnotationsActionEnum} action 
         * @param {number} id A unique integer value identifying this task.
         * @param {PatchedLabeledDataRequest} [patchedLabeledDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksPartialUpdateAnnotations: async (action: TasksPartialUpdateAnnotationsActionEnum, id: number, patchedLabeledDataRequest?: PatchedLabeledDataRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'action' is not null or undefined
            assertParamExists('tasksPartialUpdateAnnotations', 'action', action)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksPartialUpdateAnnotations', 'id', id)
            const localVarPath = `/api/tasks/{id}/annotations/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedLabeledDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update metainformation for media files in a task
         * @param {number} id A unique integer value identifying this task.
         * @param {PatchedDataMetaWriteRequest} [patchedDataMetaWriteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksPartialUpdateDataMeta: async (id: number, patchedDataMetaWriteRequest?: PatchedDataMetaWriteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksPartialUpdateDataMeta', 'id', id)
            const localVarPath = `/api/tasks/{id}/data/meta`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedDataMetaWriteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  WARNING: this operation is not protected from race conditions. It\'s up to the user to ensure no parallel calls to this operation happen. It affects image access, including exports with images, backups, chunk downloading etc. 
         * @summary Allows updating current validation configuration
         * @param {number} id A unique integer value identifying this task.
         * @param {PatchedTaskValidationLayoutWriteRequest} [patchedTaskValidationLayoutWriteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksPartialUpdateValidationLayout: async (id: number, patchedTaskValidationLayoutWriteRequest?: PatchedTaskValidationLayoutWriteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksPartialUpdateValidationLayout', 'id', id)
            const localVarPath = `/api/tasks/{id}/validation_layout`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedTaskValidationLayoutWriteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get task details
         * @param {number} id A unique integer value identifying this task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksRetrieve', 'id', id)
            const localVarPath = `/api/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deprecation warning:  Utilizing this endpoint ot export annotations as a dataset in a specific format will be deprecated in one of the next releases.  Consider using new API: - POST /api/tasks/<task_id>/dataset/export?save_images=False to initiate export process - GET /api/requests/<rq_id> to check process status,     where rq_id is request id returned on initializing request 
         * @summary Get task annotations or export them as a dataset in a specific format
         * @param {number} id A unique integer value identifying this task.
         * @param {TasksRetrieveAnnotationsActionEnum} [action] Used to start downloading process locally after annotation file has been created
         * @param {number} [cloudStorageId] Storage id
         * @param {string} [filename] Desired output file name
         * @param {string} [format] Desired output format name You can get the list of supported formats at: /server/annotation/formats
         * @param {TasksRetrieveAnnotationsLocationEnum} [location] Where need to save downloaded dataset
         * @param {boolean} [useDefaultLocation] Use the location that was configured in the task to export annotation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksRetrieveAnnotations: async (id: number, action?: TasksRetrieveAnnotationsActionEnum, cloudStorageId?: number, filename?: string, format?: string, location?: TasksRetrieveAnnotationsLocationEnum, useDefaultLocation?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksRetrieveAnnotations', 'id', id)
            const localVarPath = `/api/tasks/{id}/annotations/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }

            if (cloudStorageId !== undefined) {
                localVarQueryParameter['cloud_storage_id'] = cloudStorageId;
            }

            if (filename !== undefined) {
                localVarQueryParameter['filename'] = filename;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }

            if (useDefaultLocation !== undefined) {
                localVarQueryParameter['use_default_location'] = useDefaultLocation;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deprecation warning:     This endpoint will be deprecated in one of the next releases.     Consider using new API:     - POST /api/tasks/<task_id>/backup/export to initiate backup process     - GET /api/requests/<rq_id> to check process status,         where rq_id is request id returned on initializing request\' 
         * @summary Back up a task
         * @param {number} id A unique integer value identifying this task.
         * @param {TasksRetrieveBackupActionEnum} [action] Used to start downloading process after backup file had been created
         * @param {number} [cloudStorageId] Storage id
         * @param {string} [filename] Backup file name
         * @param {TasksRetrieveBackupLocationEnum} [location] Where need to save downloaded backup
         * @param {boolean} [useDefaultLocation] Use the location that was configured in the task to export backup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksRetrieveBackup: async (id: number, action?: TasksRetrieveBackupActionEnum, cloudStorageId?: number, filename?: string, location?: TasksRetrieveBackupLocationEnum, useDefaultLocation?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksRetrieveBackup', 'id', id)
            const localVarPath = `/api/tasks/{id}/backup`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }

            if (cloudStorageId !== undefined) {
                localVarQueryParameter['cloud_storage_id'] = cloudStorageId;
            }

            if (filename !== undefined) {
                localVarQueryParameter['filename'] = filename;
            }

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }

            if (useDefaultLocation !== undefined) {
                localVarQueryParameter['use_default_location'] = useDefaultLocation;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get data of a task
         * @param {number} id A unique integer value identifying this task.
         * @param {number} [number] A unique number value identifying chunk or frame
         * @param {TasksRetrieveDataQualityEnum} [quality] Specifies the quality level of the requested data
         * @param {TasksRetrieveDataTypeEnum} [type] Specifies the type of the requested data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksRetrieveData: async (id: number, number?: number, quality?: TasksRetrieveDataQualityEnum, type?: TasksRetrieveDataTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksRetrieveData', 'id', id)
            const localVarPath = `/api/tasks/{id}/data/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required

            if (number !== undefined) {
                localVarQueryParameter['number'] = number;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get metainformation for media files in a task
         * @param {number} id A unique integer value identifying this task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksRetrieveDataMeta: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksRetrieveDataMeta', 'id', id)
            const localVarPath = `/api/tasks/{id}/data/meta`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deprecation warning:  Utilizing this endpoint to export task dataset in a specific format will be deprecated in one of the next releases.  Consider using new API: - POST /api/tasks/<task_id>/dataset/export?save_images=True to initiate export process - GET /api/requests/<rq_id> to check process status,     where rq_id is request id returned on initializing request 
         * @summary Export task as a dataset in a specific format
         * @param {string} format Desired output format name You can get the list of supported formats at: /server/annotation/formats
         * @param {number} id A unique integer value identifying this task.
         * @param {TasksRetrieveDatasetActionEnum} [action] Used to start downloading process locally after annotation file has been created
         * @param {number} [cloudStorageId] Storage id
         * @param {string} [filename] Desired output file name
         * @param {TasksRetrieveDatasetLocationEnum} [location] Where need to save downloaded dataset
         * @param {boolean} [useDefaultLocation] Use the location that was configured in task to export annotations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksRetrieveDataset: async (format: string, id: number, action?: TasksRetrieveDatasetActionEnum, cloudStorageId?: number, filename?: string, location?: TasksRetrieveDatasetLocationEnum, useDefaultLocation?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'format' is not null or undefined
            assertParamExists('tasksRetrieveDataset', 'format', format)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksRetrieveDataset', 'id', id)
            const localVarPath = `/api/tasks/{id}/dataset`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }

            if (cloudStorageId !== undefined) {
                localVarQueryParameter['cloud_storage_id'] = cloudStorageId;
            }

            if (filename !== undefined) {
                localVarQueryParameter['filename'] = filename;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }

            if (useDefaultLocation !== undefined) {
                localVarQueryParameter['use_default_location'] = useDefaultLocation;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a preview image for a task
         * @param {number} id A unique integer value identifying this task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksRetrievePreview: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksRetrievePreview', 'id', id)
            const localVarPath = `/api/tasks/{id}/preview`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method is deprecated and will be removed in one of the next releases. To check status of task creation, use new common API for managing background operations: GET /api/requests/?action=create&task_id=<task_id>
         * @summary Get the creation status of a task
         * @param {number} id A unique integer value identifying this task.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        tasksRetrieveStatus: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksRetrieveStatus', 'id', id)
            const localVarPath = `/api/tasks/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Allows getting current validation configuration
         * @param {number} id A unique integer value identifying this task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksRetrieveValidationLayout: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksRetrieveValidationLayout', 'id', id)
            const localVarPath = `/api/tasks/{id}/validation_layout`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  To check the status of an import request:  After initiating the annotation import, you will receive an rq_id parameter. Make sure to include this parameter as a query parameter in your subsequent PUT /api/tasks/id/annotations requests to track the status of the import. 
         * @summary Replace task annotations / Get annotation import status
         * @param {number} id A unique integer value identifying this task.
         * @param {string} [format] Input format name You can get the list of supported formats at: /server/annotation/formats
         * @param {string} [rqId] rq id
         * @param {TaskAnnotationsUpdateRequest | null} [taskAnnotationsUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksUpdateAnnotations: async (id: number, format?: string, rqId?: string, taskAnnotationsUpdateRequest?: TaskAnnotationsUpdateRequest | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksUpdateAnnotations', 'id', id)
            const localVarPath = `/api/tasks/{id}/annotations/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (rqId !== undefined) {
                localVarQueryParameter['rq_id'] = rqId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taskAnnotationsUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TasksApi - functional programming interface
 * @export
 */
export const TasksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TasksApiAxiosParamCreator(configuration)
    return {
        /**
         * The new task will not have any attached images or videos. To attach them, use the /api/tasks/<id>/data endpoint. 
         * @summary Create a task
         * @param {TaskWriteRequest} taskWriteRequest 
         * @param {string} [xOrganization] Organization unique slug
         * @param {string} [org] Organization unique slug
         * @param {number} [orgId] Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksCreate(taskWriteRequest: TaskWriteRequest, xOrganization?: string, org?: string, orgId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksCreate(taskWriteRequest, xOrganization, org, orgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  The request POST /api/tasks/id/annotations will initiate the import and will create the rq job on the server in which the import will be carried out. Please, use the PUT /api/tasks/id/annotations endpoint for checking status of the process. 
         * @summary Import annotations into a task
         * @param {number} id A unique integer value identifying this task.
         * @param {number} [cloudStorageId] Storage id
         * @param {string} [filename] Annotation file name
         * @param {string} [format] Input format name You can get the list of supported formats at: /server/annotation/formats
         * @param {TasksCreateAnnotationsLocationEnum} [location] where to import the annotation from
         * @param {boolean} [useDefaultLocation] Use the location that was configured in task to import annotations
         * @param {TaskAnnotationsWriteRequest | null} [taskAnnotationsWriteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksCreateAnnotations(id: number, cloudStorageId?: number, filename?: string, format?: string, location?: TasksCreateAnnotationsLocationEnum, useDefaultLocation?: boolean, taskAnnotationsWriteRequest?: TaskAnnotationsWriteRequest | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksCreateAnnotations(id, cloudStorageId, filename, format, location, useDefaultLocation, taskAnnotationsWriteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksCreateAnnotations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  The backup import process is as follows:  The first request POST /api/tasks/backup will initiate file upload and will create the rq job on the server in which the process of a task creating from an uploaded backup will be carried out.  After initiating the backup upload, you will receive an rq_id parameter. Make sure to include this parameter as a query parameter in your subsequent requests to track the status of the task creation. Once the task has been successfully created, the server will return the id of the newly created task. 
         * @summary Recreate a task from a backup
         * @param {string} [xOrganization] Organization unique slug
         * @param {number} [cloudStorageId] Storage id
         * @param {string} [filename] Backup file name
         * @param {TasksCreateBackupLocationEnum} [location] Where to import the backup file from
         * @param {string} [org] Organization unique slug
         * @param {number} [orgId] Organization identifier
         * @param {string} [rqId] rq id
         * @param {TaskFileRequest} [taskFileRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksCreateBackup(xOrganization?: string, cloudStorageId?: number, filename?: string, location?: TasksCreateBackupLocationEnum, org?: string, orgId?: number, rqId?: string, taskFileRequest?: TaskFileRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksCreateBackup(xOrganization, cloudStorageId, filename, location, org, orgId, rqId, taskFileRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksCreateBackup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The request `POST /api/<projects|tasks>/id/backup/export` will initialize a background process to backup a resource. To check status of the process please, use `GET /api/requests/<rq_id>` where **rq_id** is request ID returned in the response for this endpoint. 
         * @summary Initiate process to backup resource
         * @param {number} id A unique integer value identifying this task.
         * @param {number} [cloudStorageId] Storage id
         * @param {string} [filename] Backup file name
         * @param {TasksCreateBackupExportLocationEnum} [location] Where need to save downloaded backup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksCreateBackupExport(id: number, cloudStorageId?: number, filename?: string, location?: TasksCreateBackupExportLocationEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RqId>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksCreateBackupExport(id, cloudStorageId, filename, location, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksCreateBackupExport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows to upload data (images, video, etc.) to a task. Supports the TUS open file uploading protocol (https://tus.io/).  Supports the following protocols:  1. A single Data request  and  2.1. An Upload-Start request 2.2.a. Regular TUS protocol requests (Upload-Length + Chunks) 2.2.b. Upload-Multiple requests 2.3. An Upload-Finish request  Requests: - Data - POST, no extra headers or \'Upload-Start\' + \'Upload-Finish\' headers.   Contains data in the body. - Upload-Start - POST, has an \'Upload-Start\' header. No body is expected. - Upload-Length - POST, has an \'Upload-Length\' header (see the TUS specification) - Chunk - HEAD/PATCH (see the TUS specification). Sent to /data/<file id> endpoints. - Upload-Finish - POST, has an \'Upload-Finish\' header. Can contain data in the body. - Upload-Multiple - POST, has an \'Upload-Multiple\' header. Contains data in the body.  The \'Upload-Finish\' request allows to specify the uploaded files should be ordered. This may be needed if the files can be sent unordered. To state that the input files are sent ordered, pass an empty list of files in the \'upload_file_order\' field. If the files are sent unordered, the ordered file list is expected in the \'upload_file_order\' field. It must be a list of string file paths, relative to the dataset root.  Example: files = [     \"cats/cat_1.jpg\",     \"dogs/dog2.jpg\",     \"image_3.png\",     ... ]  Independently of the file declaration field used (\'client_files\', \'server_files\', etc.), when the \'predefined\' sorting method is selected, the uploaded files will be ordered according to the \'.jsonl\' manifest file, if it is found in the list of files. For archives (e.g. \'.zip\'), a manifest file (\'*.jsonl\') is required when using the \'predefined\' file ordering. Such file must be provided next to the archive in the list of files. Read more about manifest files here: https://docs.cvat.ai/docs/manual/advanced/dataset_manifest/  After all data is sent, the operation status can be retrieved via the `GET /api/requests/<rq_id>`, where **rq_id** is request ID returned for this request.  Once data is attached to a task, it cannot be detached or replaced. 
         * @summary Attach data to a task
         * @param {number} id A unique integer value identifying this task.
         * @param {boolean} [uploadFinish] Finishes data upload. Can be combined with Upload-Start header to create task data with one request
         * @param {boolean} [uploadMultiple] Indicates that data with this request are single or multiple files that should be attached to a task
         * @param {boolean} [uploadStart] Initializes data upload. Optionally, can include upload metadata in the request body.
         * @param {DataRequest} [dataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksCreateData(id: number, uploadFinish?: boolean, uploadMultiple?: boolean, uploadStart?: boolean, dataRequest?: DataRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksCreateData(id, uploadFinish, uploadMultiple, uploadStart, dataRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksCreateData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The request `POST /api/<projects|tasks|jobs>/id/dataset/export` will initialize a background process to export a dataset. To check status of the process please, use `GET /api/requests/<rq_id>` where **rq_id** is request ID returned in the response for this endpoint. 
         * @summary Initialize process to export resource as a dataset in a specific format
         * @param {string} format Desired output format name You can get the list of supported formats at: /server/annotation/formats
         * @param {number} id A unique integer value identifying this task.
         * @param {number} [cloudStorageId] Storage id
         * @param {string} [filename] Desired output file name
         * @param {TasksCreateDatasetExportLocationEnum} [location] Where need to save downloaded dataset
         * @param {boolean} [saveImages] Include images or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksCreateDatasetExport(format: string, id: number, cloudStorageId?: number, filename?: string, location?: TasksCreateDatasetExportLocationEnum, saveImages?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RqId>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksCreateDatasetExport(format, id, cloudStorageId, filename, location, saveImages, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksCreateDatasetExport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * All attached jobs, annotations and data will be deleted as well.
         * @summary Delete a task
         * @param {number} id A unique integer value identifying this task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete task annotations
         * @param {number} id A unique integer value identifying this task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksDestroyAnnotations(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksDestroyAnnotations(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksDestroyAnnotations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List tasks
         * @param {string} [xOrganization] Organization unique slug
         * @param {string} [assignee] A simple equality filter for the assignee field
         * @param {TasksListDimensionEnum} [dimension] A simple equality filter for the dimension field
         * @param {string} [filter]  JSON Logic filter. This filter can be used to perform complex filtering by grouping rules.  For example, using such a filter you can get all resources created by you:      - {\&quot;and\&quot;:[{\&quot;&#x3D;&#x3D;\&quot;:[{\&quot;var\&quot;:\&quot;owner\&quot;},\&quot;&lt;user&gt;\&quot;]}]}  Details about the syntax used can be found at the link: https://jsonlogic.com/   Available filter_fields: [\&#39;project_name\&#39;, \&#39;name\&#39;, \&#39;owner\&#39;, \&#39;status\&#39;, \&#39;assignee\&#39;, \&#39;subset\&#39;, \&#39;mode\&#39;, \&#39;dimension\&#39;, \&#39;tracker_link\&#39;, \&#39;validation_mode\&#39;, \&#39;id\&#39;, \&#39;project_id\&#39;, \&#39;updated_date\&#39;].  There are few examples for complex filtering tasks:      - Get all tasks from 1,2,3 projects - { \&quot;and\&quot; : [{ \&quot;in\&quot; : [{ \&quot;var\&quot; : \&quot;project_id\&quot; }, [1, 2, 3]]}]}      - Get all completed tasks from 1 project - { \&quot;and\&quot;: [{ \&quot;&#x3D;&#x3D;\&quot;: [{ \&quot;var\&quot; : \&quot;status\&quot; }, \&quot;completed\&quot;]}, { \&quot;&#x3D;&#x3D;\&quot; : [{ \&quot;var\&quot; : \&quot;project_id\&quot;}, 1]}]}  
         * @param {string} [mode] A simple equality filter for the mode field
         * @param {string} [name] A simple equality filter for the name field
         * @param {string} [org] Organization unique slug
         * @param {number} [orgId] Organization identifier
         * @param {string} [owner] A simple equality filter for the owner field
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [projectId] A simple equality filter for the project_id field
         * @param {string} [projectName] A simple equality filter for the project_name field
         * @param {string} [search] A search term. Available search_fields: (\&#39;project_name\&#39;, \&#39;name\&#39;, \&#39;owner\&#39;, \&#39;status\&#39;, \&#39;assignee\&#39;, \&#39;subset\&#39;, \&#39;mode\&#39;, \&#39;dimension\&#39;, \&#39;tracker_link\&#39;, \&#39;validation_mode\&#39;)
         * @param {string} [sort] Which field to use when ordering the results. Available ordering_fields: [\&#39;project_name\&#39;, \&#39;name\&#39;, \&#39;owner\&#39;, \&#39;status\&#39;, \&#39;assignee\&#39;, \&#39;subset\&#39;, \&#39;mode\&#39;, \&#39;dimension\&#39;, \&#39;tracker_link\&#39;, \&#39;validation_mode\&#39;, \&#39;id\&#39;, \&#39;project_id\&#39;, \&#39;updated_date\&#39;]
         * @param {TasksListStatusEnum} [status] A simple equality filter for the status field
         * @param {string} [subset] A simple equality filter for the subset field
         * @param {string} [trackerLink] A simple equality filter for the tracker_link field
         * @param {TasksListValidationModeEnum} [validationMode] A simple equality filter for the validation_mode field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksList(xOrganization?: string, assignee?: string, dimension?: TasksListDimensionEnum, filter?: string, mode?: string, name?: string, org?: string, orgId?: number, owner?: string, page?: number, pageSize?: number, projectId?: number, projectName?: string, search?: string, sort?: string, status?: TasksListStatusEnum, subset?: string, trackerLink?: string, validationMode?: TasksListValidationModeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedTaskReadList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksList(xOrganization, assignee, dimension, filter, mode, name, org, orgId, owner, page, pageSize, projectId, projectName, search, sort, status, subset, trackerLink, validationMode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a task
         * @param {number} id A unique integer value identifying this task.
         * @param {PatchedTaskWriteRequest} [patchedTaskWriteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksPartialUpdate(id: number, patchedTaskWriteRequest?: PatchedTaskWriteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksPartialUpdate(id, patchedTaskWriteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update task annotations
         * @param {TasksPartialUpdateAnnotationsActionEnum} action 
         * @param {number} id A unique integer value identifying this task.
         * @param {PatchedLabeledDataRequest} [patchedLabeledDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksPartialUpdateAnnotations(action: TasksPartialUpdateAnnotationsActionEnum, id: number, patchedLabeledDataRequest?: PatchedLabeledDataRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabeledData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksPartialUpdateAnnotations(action, id, patchedLabeledDataRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksPartialUpdateAnnotations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update metainformation for media files in a task
         * @param {number} id A unique integer value identifying this task.
         * @param {PatchedDataMetaWriteRequest} [patchedDataMetaWriteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksPartialUpdateDataMeta(id: number, patchedDataMetaWriteRequest?: PatchedDataMetaWriteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataMetaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksPartialUpdateDataMeta(id, patchedDataMetaWriteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksPartialUpdateDataMeta']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  WARNING: this operation is not protected from race conditions. It\'s up to the user to ensure no parallel calls to this operation happen. It affects image access, including exports with images, backups, chunk downloading etc. 
         * @summary Allows updating current validation configuration
         * @param {number} id A unique integer value identifying this task.
         * @param {PatchedTaskValidationLayoutWriteRequest} [patchedTaskValidationLayoutWriteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksPartialUpdateValidationLayout(id: number, patchedTaskValidationLayoutWriteRequest?: PatchedTaskValidationLayoutWriteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskValidationLayoutRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksPartialUpdateValidationLayout(id, patchedTaskValidationLayoutWriteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksPartialUpdateValidationLayout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get task details
         * @param {number} id A unique integer value identifying this task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deprecation warning:  Utilizing this endpoint ot export annotations as a dataset in a specific format will be deprecated in one of the next releases.  Consider using new API: - POST /api/tasks/<task_id>/dataset/export?save_images=False to initiate export process - GET /api/requests/<rq_id> to check process status,     where rq_id is request id returned on initializing request 
         * @summary Get task annotations or export them as a dataset in a specific format
         * @param {number} id A unique integer value identifying this task.
         * @param {TasksRetrieveAnnotationsActionEnum} [action] Used to start downloading process locally after annotation file has been created
         * @param {number} [cloudStorageId] Storage id
         * @param {string} [filename] Desired output file name
         * @param {string} [format] Desired output format name You can get the list of supported formats at: /server/annotation/formats
         * @param {TasksRetrieveAnnotationsLocationEnum} [location] Where need to save downloaded dataset
         * @param {boolean} [useDefaultLocation] Use the location that was configured in the task to export annotation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksRetrieveAnnotations(id: number, action?: TasksRetrieveAnnotationsActionEnum, cloudStorageId?: number, filename?: string, format?: string, location?: TasksRetrieveAnnotationsLocationEnum, useDefaultLocation?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnotationsRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksRetrieveAnnotations(id, action, cloudStorageId, filename, format, location, useDefaultLocation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksRetrieveAnnotations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deprecation warning:     This endpoint will be deprecated in one of the next releases.     Consider using new API:     - POST /api/tasks/<task_id>/backup/export to initiate backup process     - GET /api/requests/<rq_id> to check process status,         where rq_id is request id returned on initializing request\' 
         * @summary Back up a task
         * @param {number} id A unique integer value identifying this task.
         * @param {TasksRetrieveBackupActionEnum} [action] Used to start downloading process after backup file had been created
         * @param {number} [cloudStorageId] Storage id
         * @param {string} [filename] Backup file name
         * @param {TasksRetrieveBackupLocationEnum} [location] Where need to save downloaded backup
         * @param {boolean} [useDefaultLocation] Use the location that was configured in the task to export backup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksRetrieveBackup(id: number, action?: TasksRetrieveBackupActionEnum, cloudStorageId?: number, filename?: string, location?: TasksRetrieveBackupLocationEnum, useDefaultLocation?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksRetrieveBackup(id, action, cloudStorageId, filename, location, useDefaultLocation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksRetrieveBackup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get data of a task
         * @param {number} id A unique integer value identifying this task.
         * @param {number} [number] A unique number value identifying chunk or frame
         * @param {TasksRetrieveDataQualityEnum} [quality] Specifies the quality level of the requested data
         * @param {TasksRetrieveDataTypeEnum} [type] Specifies the type of the requested data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksRetrieveData(id: number, number?: number, quality?: TasksRetrieveDataQualityEnum, type?: TasksRetrieveDataTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksRetrieveData(id, number, quality, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksRetrieveData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get metainformation for media files in a task
         * @param {number} id A unique integer value identifying this task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksRetrieveDataMeta(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataMetaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksRetrieveDataMeta(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksRetrieveDataMeta']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deprecation warning:  Utilizing this endpoint to export task dataset in a specific format will be deprecated in one of the next releases.  Consider using new API: - POST /api/tasks/<task_id>/dataset/export?save_images=True to initiate export process - GET /api/requests/<rq_id> to check process status,     where rq_id is request id returned on initializing request 
         * @summary Export task as a dataset in a specific format
         * @param {string} format Desired output format name You can get the list of supported formats at: /server/annotation/formats
         * @param {number} id A unique integer value identifying this task.
         * @param {TasksRetrieveDatasetActionEnum} [action] Used to start downloading process locally after annotation file has been created
         * @param {number} [cloudStorageId] Storage id
         * @param {string} [filename] Desired output file name
         * @param {TasksRetrieveDatasetLocationEnum} [location] Where need to save downloaded dataset
         * @param {boolean} [useDefaultLocation] Use the location that was configured in task to export annotations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksRetrieveDataset(format: string, id: number, action?: TasksRetrieveDatasetActionEnum, cloudStorageId?: number, filename?: string, location?: TasksRetrieveDatasetLocationEnum, useDefaultLocation?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksRetrieveDataset(format, id, action, cloudStorageId, filename, location, useDefaultLocation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksRetrieveDataset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a preview image for a task
         * @param {number} id A unique integer value identifying this task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksRetrievePreview(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksRetrievePreview(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksRetrievePreview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This method is deprecated and will be removed in one of the next releases. To check status of task creation, use new common API for managing background operations: GET /api/requests/?action=create&task_id=<task_id>
         * @summary Get the creation status of a task
         * @param {number} id A unique integer value identifying this task.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async tasksRetrieveStatus(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RqStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksRetrieveStatus(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksRetrieveStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Allows getting current validation configuration
         * @param {number} id A unique integer value identifying this task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksRetrieveValidationLayout(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskValidationLayoutRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksRetrieveValidationLayout(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksRetrieveValidationLayout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  To check the status of an import request:  After initiating the annotation import, you will receive an rq_id parameter. Make sure to include this parameter as a query parameter in your subsequent PUT /api/tasks/id/annotations requests to track the status of the import. 
         * @summary Replace task annotations / Get annotation import status
         * @param {number} id A unique integer value identifying this task.
         * @param {string} [format] Input format name You can get the list of supported formats at: /server/annotation/formats
         * @param {string} [rqId] rq id
         * @param {TaskAnnotationsUpdateRequest | null} [taskAnnotationsUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksUpdateAnnotations(id: number, format?: string, rqId?: string, taskAnnotationsUpdateRequest?: TaskAnnotationsUpdateRequest | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksUpdateAnnotations(id, format, rqId, taskAnnotationsUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksUpdateAnnotations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TasksApi - factory interface
 * @export
 */
export const TasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TasksApiFp(configuration)
    return {
        /**
         * The new task will not have any attached images or videos. To attach them, use the /api/tasks/<id>/data endpoint. 
         * @summary Create a task
         * @param {TasksApiTasksCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksCreate(requestParameters: TasksApiTasksCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskRead> {
            return localVarFp.tasksCreate(requestParameters.taskWriteRequest, requestParameters.xOrganization, requestParameters.org, requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         *  The request POST /api/tasks/id/annotations will initiate the import and will create the rq job on the server in which the import will be carried out. Please, use the PUT /api/tasks/id/annotations endpoint for checking status of the process. 
         * @summary Import annotations into a task
         * @param {TasksApiTasksCreateAnnotationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksCreateAnnotations(requestParameters: TasksApiTasksCreateAnnotationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.tasksCreateAnnotations(requestParameters.id, requestParameters.cloudStorageId, requestParameters.filename, requestParameters.format, requestParameters.location, requestParameters.useDefaultLocation, requestParameters.taskAnnotationsWriteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *  The backup import process is as follows:  The first request POST /api/tasks/backup will initiate file upload and will create the rq job on the server in which the process of a task creating from an uploaded backup will be carried out.  After initiating the backup upload, you will receive an rq_id parameter. Make sure to include this parameter as a query parameter in your subsequent requests to track the status of the task creation. Once the task has been successfully created, the server will return the id of the newly created task. 
         * @summary Recreate a task from a backup
         * @param {TasksApiTasksCreateBackupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksCreateBackup(requestParameters: TasksApiTasksCreateBackupRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.tasksCreateBackup(requestParameters.xOrganization, requestParameters.cloudStorageId, requestParameters.filename, requestParameters.location, requestParameters.org, requestParameters.orgId, requestParameters.rqId, requestParameters.taskFileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * The request `POST /api/<projects|tasks>/id/backup/export` will initialize a background process to backup a resource. To check status of the process please, use `GET /api/requests/<rq_id>` where **rq_id** is request ID returned in the response for this endpoint. 
         * @summary Initiate process to backup resource
         * @param {TasksApiTasksCreateBackupExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksCreateBackupExport(requestParameters: TasksApiTasksCreateBackupExportRequest, options?: RawAxiosRequestConfig): AxiosPromise<RqId> {
            return localVarFp.tasksCreateBackupExport(requestParameters.id, requestParameters.cloudStorageId, requestParameters.filename, requestParameters.location, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows to upload data (images, video, etc.) to a task. Supports the TUS open file uploading protocol (https://tus.io/).  Supports the following protocols:  1. A single Data request  and  2.1. An Upload-Start request 2.2.a. Regular TUS protocol requests (Upload-Length + Chunks) 2.2.b. Upload-Multiple requests 2.3. An Upload-Finish request  Requests: - Data - POST, no extra headers or \'Upload-Start\' + \'Upload-Finish\' headers.   Contains data in the body. - Upload-Start - POST, has an \'Upload-Start\' header. No body is expected. - Upload-Length - POST, has an \'Upload-Length\' header (see the TUS specification) - Chunk - HEAD/PATCH (see the TUS specification). Sent to /data/<file id> endpoints. - Upload-Finish - POST, has an \'Upload-Finish\' header. Can contain data in the body. - Upload-Multiple - POST, has an \'Upload-Multiple\' header. Contains data in the body.  The \'Upload-Finish\' request allows to specify the uploaded files should be ordered. This may be needed if the files can be sent unordered. To state that the input files are sent ordered, pass an empty list of files in the \'upload_file_order\' field. If the files are sent unordered, the ordered file list is expected in the \'upload_file_order\' field. It must be a list of string file paths, relative to the dataset root.  Example: files = [     \"cats/cat_1.jpg\",     \"dogs/dog2.jpg\",     \"image_3.png\",     ... ]  Independently of the file declaration field used (\'client_files\', \'server_files\', etc.), when the \'predefined\' sorting method is selected, the uploaded files will be ordered according to the \'.jsonl\' manifest file, if it is found in the list of files. For archives (e.g. \'.zip\'), a manifest file (\'*.jsonl\') is required when using the \'predefined\' file ordering. Such file must be provided next to the archive in the list of files. Read more about manifest files here: https://docs.cvat.ai/docs/manual/advanced/dataset_manifest/  After all data is sent, the operation status can be retrieved via the `GET /api/requests/<rq_id>`, where **rq_id** is request ID returned for this request.  Once data is attached to a task, it cannot be detached or replaced. 
         * @summary Attach data to a task
         * @param {TasksApiTasksCreateDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksCreateData(requestParameters: TasksApiTasksCreateDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<DataResponse> {
            return localVarFp.tasksCreateData(requestParameters.id, requestParameters.uploadFinish, requestParameters.uploadMultiple, requestParameters.uploadStart, requestParameters.dataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * The request `POST /api/<projects|tasks|jobs>/id/dataset/export` will initialize a background process to export a dataset. To check status of the process please, use `GET /api/requests/<rq_id>` where **rq_id** is request ID returned in the response for this endpoint. 
         * @summary Initialize process to export resource as a dataset in a specific format
         * @param {TasksApiTasksCreateDatasetExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksCreateDatasetExport(requestParameters: TasksApiTasksCreateDatasetExportRequest, options?: RawAxiosRequestConfig): AxiosPromise<RqId> {
            return localVarFp.tasksCreateDatasetExport(requestParameters.format, requestParameters.id, requestParameters.cloudStorageId, requestParameters.filename, requestParameters.location, requestParameters.saveImages, options).then((request) => request(axios, basePath));
        },
        /**
         * All attached jobs, annotations and data will be deleted as well.
         * @summary Delete a task
         * @param {TasksApiTasksDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksDestroy(requestParameters: TasksApiTasksDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.tasksDestroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete task annotations
         * @param {TasksApiTasksDestroyAnnotationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksDestroyAnnotations(requestParameters: TasksApiTasksDestroyAnnotationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.tasksDestroyAnnotations(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List tasks
         * @param {TasksApiTasksListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksList(requestParameters: TasksApiTasksListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedTaskReadList> {
            return localVarFp.tasksList(requestParameters.xOrganization, requestParameters.assignee, requestParameters.dimension, requestParameters.filter, requestParameters.mode, requestParameters.name, requestParameters.org, requestParameters.orgId, requestParameters.owner, requestParameters.page, requestParameters.pageSize, requestParameters.projectId, requestParameters.projectName, requestParameters.search, requestParameters.sort, requestParameters.status, requestParameters.subset, requestParameters.trackerLink, requestParameters.validationMode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a task
         * @param {TasksApiTasksPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksPartialUpdate(requestParameters: TasksApiTasksPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskRead> {
            return localVarFp.tasksPartialUpdate(requestParameters.id, requestParameters.patchedTaskWriteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update task annotations
         * @param {TasksApiTasksPartialUpdateAnnotationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksPartialUpdateAnnotations(requestParameters: TasksApiTasksPartialUpdateAnnotationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<LabeledData> {
            return localVarFp.tasksPartialUpdateAnnotations(requestParameters.action, requestParameters.id, requestParameters.patchedLabeledDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update metainformation for media files in a task
         * @param {TasksApiTasksPartialUpdateDataMetaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksPartialUpdateDataMeta(requestParameters: TasksApiTasksPartialUpdateDataMetaRequest, options?: RawAxiosRequestConfig): AxiosPromise<DataMetaRead> {
            return localVarFp.tasksPartialUpdateDataMeta(requestParameters.id, requestParameters.patchedDataMetaWriteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *  WARNING: this operation is not protected from race conditions. It\'s up to the user to ensure no parallel calls to this operation happen. It affects image access, including exports with images, backups, chunk downloading etc. 
         * @summary Allows updating current validation configuration
         * @param {TasksApiTasksPartialUpdateValidationLayoutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksPartialUpdateValidationLayout(requestParameters: TasksApiTasksPartialUpdateValidationLayoutRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskValidationLayoutRead> {
            return localVarFp.tasksPartialUpdateValidationLayout(requestParameters.id, requestParameters.patchedTaskValidationLayoutWriteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get task details
         * @param {TasksApiTasksRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksRetrieve(requestParameters: TasksApiTasksRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskRead> {
            return localVarFp.tasksRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Deprecation warning:  Utilizing this endpoint ot export annotations as a dataset in a specific format will be deprecated in one of the next releases.  Consider using new API: - POST /api/tasks/<task_id>/dataset/export?save_images=False to initiate export process - GET /api/requests/<rq_id> to check process status,     where rq_id is request id returned on initializing request 
         * @summary Get task annotations or export them as a dataset in a specific format
         * @param {TasksApiTasksRetrieveAnnotationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksRetrieveAnnotations(requestParameters: TasksApiTasksRetrieveAnnotationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<AnnotationsRead> {
            return localVarFp.tasksRetrieveAnnotations(requestParameters.id, requestParameters.action, requestParameters.cloudStorageId, requestParameters.filename, requestParameters.format, requestParameters.location, requestParameters.useDefaultLocation, options).then((request) => request(axios, basePath));
        },
        /**
         * Deprecation warning:     This endpoint will be deprecated in one of the next releases.     Consider using new API:     - POST /api/tasks/<task_id>/backup/export to initiate backup process     - GET /api/requests/<rq_id> to check process status,         where rq_id is request id returned on initializing request\' 
         * @summary Back up a task
         * @param {TasksApiTasksRetrieveBackupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksRetrieveBackup(requestParameters: TasksApiTasksRetrieveBackupRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.tasksRetrieveBackup(requestParameters.id, requestParameters.action, requestParameters.cloudStorageId, requestParameters.filename, requestParameters.location, requestParameters.useDefaultLocation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get data of a task
         * @param {TasksApiTasksRetrieveDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksRetrieveData(requestParameters: TasksApiTasksRetrieveDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.tasksRetrieveData(requestParameters.id, requestParameters.number, requestParameters.quality, requestParameters.type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get metainformation for media files in a task
         * @param {TasksApiTasksRetrieveDataMetaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksRetrieveDataMeta(requestParameters: TasksApiTasksRetrieveDataMetaRequest, options?: RawAxiosRequestConfig): AxiosPromise<DataMetaRead> {
            return localVarFp.tasksRetrieveDataMeta(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Deprecation warning:  Utilizing this endpoint to export task dataset in a specific format will be deprecated in one of the next releases.  Consider using new API: - POST /api/tasks/<task_id>/dataset/export?save_images=True to initiate export process - GET /api/requests/<rq_id> to check process status,     where rq_id is request id returned on initializing request 
         * @summary Export task as a dataset in a specific format
         * @param {TasksApiTasksRetrieveDatasetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksRetrieveDataset(requestParameters: TasksApiTasksRetrieveDatasetRequest, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.tasksRetrieveDataset(requestParameters.format, requestParameters.id, requestParameters.action, requestParameters.cloudStorageId, requestParameters.filename, requestParameters.location, requestParameters.useDefaultLocation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a preview image for a task
         * @param {TasksApiTasksRetrievePreviewRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksRetrievePreview(requestParameters: TasksApiTasksRetrievePreviewRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.tasksRetrievePreview(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This method is deprecated and will be removed in one of the next releases. To check status of task creation, use new common API for managing background operations: GET /api/requests/?action=create&task_id=<task_id>
         * @summary Get the creation status of a task
         * @param {TasksApiTasksRetrieveStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        tasksRetrieveStatus(requestParameters: TasksApiTasksRetrieveStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<RqStatus> {
            return localVarFp.tasksRetrieveStatus(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Allows getting current validation configuration
         * @param {TasksApiTasksRetrieveValidationLayoutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksRetrieveValidationLayout(requestParameters: TasksApiTasksRetrieveValidationLayoutRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskValidationLayoutRead> {
            return localVarFp.tasksRetrieveValidationLayout(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *  To check the status of an import request:  After initiating the annotation import, you will receive an rq_id parameter. Make sure to include this parameter as a query parameter in your subsequent PUT /api/tasks/id/annotations requests to track the status of the import. 
         * @summary Replace task annotations / Get annotation import status
         * @param {TasksApiTasksUpdateAnnotationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksUpdateAnnotations(requestParameters: TasksApiTasksUpdateAnnotationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.tasksUpdateAnnotations(requestParameters.id, requestParameters.format, requestParameters.rqId, requestParameters.taskAnnotationsUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for tasksCreate operation in TasksApi.
 * @export
 * @interface TasksApiTasksCreateRequest
 */
export interface TasksApiTasksCreateRequest {
    /**
     * 
     * @type {TaskWriteRequest}
     * @memberof TasksApiTasksCreate
     */
    readonly taskWriteRequest: TaskWriteRequest

    /**
     * Organization unique slug
     * @type {string}
     * @memberof TasksApiTasksCreate
     */
    readonly xOrganization?: string

    /**
     * Organization unique slug
     * @type {string}
     * @memberof TasksApiTasksCreate
     */
    readonly org?: string

    /**
     * Organization identifier
     * @type {number}
     * @memberof TasksApiTasksCreate
     */
    readonly orgId?: number
}

/**
 * Request parameters for tasksCreateAnnotations operation in TasksApi.
 * @export
 * @interface TasksApiTasksCreateAnnotationsRequest
 */
export interface TasksApiTasksCreateAnnotationsRequest {
    /**
     * A unique integer value identifying this task.
     * @type {number}
     * @memberof TasksApiTasksCreateAnnotations
     */
    readonly id: number

    /**
     * Storage id
     * @type {number}
     * @memberof TasksApiTasksCreateAnnotations
     */
    readonly cloudStorageId?: number

    /**
     * Annotation file name
     * @type {string}
     * @memberof TasksApiTasksCreateAnnotations
     */
    readonly filename?: string

    /**
     * Input format name You can get the list of supported formats at: /server/annotation/formats
     * @type {string}
     * @memberof TasksApiTasksCreateAnnotations
     */
    readonly format?: string

    /**
     * where to import the annotation from
     * @type {'cloud_storage' | 'local'}
     * @memberof TasksApiTasksCreateAnnotations
     */
    readonly location?: TasksCreateAnnotationsLocationEnum

    /**
     * Use the location that was configured in task to import annotations
     * @type {boolean}
     * @memberof TasksApiTasksCreateAnnotations
     */
    readonly useDefaultLocation?: boolean

    /**
     * 
     * @type {TaskAnnotationsWriteRequest}
     * @memberof TasksApiTasksCreateAnnotations
     */
    readonly taskAnnotationsWriteRequest?: TaskAnnotationsWriteRequest | null
}

/**
 * Request parameters for tasksCreateBackup operation in TasksApi.
 * @export
 * @interface TasksApiTasksCreateBackupRequest
 */
export interface TasksApiTasksCreateBackupRequest {
    /**
     * Organization unique slug
     * @type {string}
     * @memberof TasksApiTasksCreateBackup
     */
    readonly xOrganization?: string

    /**
     * Storage id
     * @type {number}
     * @memberof TasksApiTasksCreateBackup
     */
    readonly cloudStorageId?: number

    /**
     * Backup file name
     * @type {string}
     * @memberof TasksApiTasksCreateBackup
     */
    readonly filename?: string

    /**
     * Where to import the backup file from
     * @type {'cloud_storage' | 'local'}
     * @memberof TasksApiTasksCreateBackup
     */
    readonly location?: TasksCreateBackupLocationEnum

    /**
     * Organization unique slug
     * @type {string}
     * @memberof TasksApiTasksCreateBackup
     */
    readonly org?: string

    /**
     * Organization identifier
     * @type {number}
     * @memberof TasksApiTasksCreateBackup
     */
    readonly orgId?: number

    /**
     * rq id
     * @type {string}
     * @memberof TasksApiTasksCreateBackup
     */
    readonly rqId?: string

    /**
     * 
     * @type {TaskFileRequest}
     * @memberof TasksApiTasksCreateBackup
     */
    readonly taskFileRequest?: TaskFileRequest
}

/**
 * Request parameters for tasksCreateBackupExport operation in TasksApi.
 * @export
 * @interface TasksApiTasksCreateBackupExportRequest
 */
export interface TasksApiTasksCreateBackupExportRequest {
    /**
     * A unique integer value identifying this task.
     * @type {number}
     * @memberof TasksApiTasksCreateBackupExport
     */
    readonly id: number

    /**
     * Storage id
     * @type {number}
     * @memberof TasksApiTasksCreateBackupExport
     */
    readonly cloudStorageId?: number

    /**
     * Backup file name
     * @type {string}
     * @memberof TasksApiTasksCreateBackupExport
     */
    readonly filename?: string

    /**
     * Where need to save downloaded backup
     * @type {'cloud_storage' | 'local'}
     * @memberof TasksApiTasksCreateBackupExport
     */
    readonly location?: TasksCreateBackupExportLocationEnum
}

/**
 * Request parameters for tasksCreateData operation in TasksApi.
 * @export
 * @interface TasksApiTasksCreateDataRequest
 */
export interface TasksApiTasksCreateDataRequest {
    /**
     * A unique integer value identifying this task.
     * @type {number}
     * @memberof TasksApiTasksCreateData
     */
    readonly id: number

    /**
     * Finishes data upload. Can be combined with Upload-Start header to create task data with one request
     * @type {boolean}
     * @memberof TasksApiTasksCreateData
     */
    readonly uploadFinish?: boolean

    /**
     * Indicates that data with this request are single or multiple files that should be attached to a task
     * @type {boolean}
     * @memberof TasksApiTasksCreateData
     */
    readonly uploadMultiple?: boolean

    /**
     * Initializes data upload. Optionally, can include upload metadata in the request body.
     * @type {boolean}
     * @memberof TasksApiTasksCreateData
     */
    readonly uploadStart?: boolean

    /**
     * 
     * @type {DataRequest}
     * @memberof TasksApiTasksCreateData
     */
    readonly dataRequest?: DataRequest
}

/**
 * Request parameters for tasksCreateDatasetExport operation in TasksApi.
 * @export
 * @interface TasksApiTasksCreateDatasetExportRequest
 */
export interface TasksApiTasksCreateDatasetExportRequest {
    /**
     * Desired output format name You can get the list of supported formats at: /server/annotation/formats
     * @type {string}
     * @memberof TasksApiTasksCreateDatasetExport
     */
    readonly format: string

    /**
     * A unique integer value identifying this task.
     * @type {number}
     * @memberof TasksApiTasksCreateDatasetExport
     */
    readonly id: number

    /**
     * Storage id
     * @type {number}
     * @memberof TasksApiTasksCreateDatasetExport
     */
    readonly cloudStorageId?: number

    /**
     * Desired output file name
     * @type {string}
     * @memberof TasksApiTasksCreateDatasetExport
     */
    readonly filename?: string

    /**
     * Where need to save downloaded dataset
     * @type {'cloud_storage' | 'local'}
     * @memberof TasksApiTasksCreateDatasetExport
     */
    readonly location?: TasksCreateDatasetExportLocationEnum

    /**
     * Include images or not
     * @type {boolean}
     * @memberof TasksApiTasksCreateDatasetExport
     */
    readonly saveImages?: boolean
}

/**
 * Request parameters for tasksDestroy operation in TasksApi.
 * @export
 * @interface TasksApiTasksDestroyRequest
 */
export interface TasksApiTasksDestroyRequest {
    /**
     * A unique integer value identifying this task.
     * @type {number}
     * @memberof TasksApiTasksDestroy
     */
    readonly id: number
}

/**
 * Request parameters for tasksDestroyAnnotations operation in TasksApi.
 * @export
 * @interface TasksApiTasksDestroyAnnotationsRequest
 */
export interface TasksApiTasksDestroyAnnotationsRequest {
    /**
     * A unique integer value identifying this task.
     * @type {number}
     * @memberof TasksApiTasksDestroyAnnotations
     */
    readonly id: number
}

/**
 * Request parameters for tasksList operation in TasksApi.
 * @export
 * @interface TasksApiTasksListRequest
 */
export interface TasksApiTasksListRequest {
    /**
     * Organization unique slug
     * @type {string}
     * @memberof TasksApiTasksList
     */
    readonly xOrganization?: string

    /**
     * A simple equality filter for the assignee field
     * @type {string}
     * @memberof TasksApiTasksList
     */
    readonly assignee?: string

    /**
     * A simple equality filter for the dimension field
     * @type {'3d' | '2d'}
     * @memberof TasksApiTasksList
     */
    readonly dimension?: TasksListDimensionEnum

    /**
     *  JSON Logic filter. This filter can be used to perform complex filtering by grouping rules.  For example, using such a filter you can get all resources created by you:      - {\&quot;and\&quot;:[{\&quot;&#x3D;&#x3D;\&quot;:[{\&quot;var\&quot;:\&quot;owner\&quot;},\&quot;&lt;user&gt;\&quot;]}]}  Details about the syntax used can be found at the link: https://jsonlogic.com/   Available filter_fields: [\&#39;project_name\&#39;, \&#39;name\&#39;, \&#39;owner\&#39;, \&#39;status\&#39;, \&#39;assignee\&#39;, \&#39;subset\&#39;, \&#39;mode\&#39;, \&#39;dimension\&#39;, \&#39;tracker_link\&#39;, \&#39;validation_mode\&#39;, \&#39;id\&#39;, \&#39;project_id\&#39;, \&#39;updated_date\&#39;].  There are few examples for complex filtering tasks:      - Get all tasks from 1,2,3 projects - { \&quot;and\&quot; : [{ \&quot;in\&quot; : [{ \&quot;var\&quot; : \&quot;project_id\&quot; }, [1, 2, 3]]}]}      - Get all completed tasks from 1 project - { \&quot;and\&quot;: [{ \&quot;&#x3D;&#x3D;\&quot;: [{ \&quot;var\&quot; : \&quot;status\&quot; }, \&quot;completed\&quot;]}, { \&quot;&#x3D;&#x3D;\&quot; : [{ \&quot;var\&quot; : \&quot;project_id\&quot;}, 1]}]}  
     * @type {string}
     * @memberof TasksApiTasksList
     */
    readonly filter?: string

    /**
     * A simple equality filter for the mode field
     * @type {string}
     * @memberof TasksApiTasksList
     */
    readonly mode?: string

    /**
     * A simple equality filter for the name field
     * @type {string}
     * @memberof TasksApiTasksList
     */
    readonly name?: string

    /**
     * Organization unique slug
     * @type {string}
     * @memberof TasksApiTasksList
     */
    readonly org?: string

    /**
     * Organization identifier
     * @type {number}
     * @memberof TasksApiTasksList
     */
    readonly orgId?: number

    /**
     * A simple equality filter for the owner field
     * @type {string}
     * @memberof TasksApiTasksList
     */
    readonly owner?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof TasksApiTasksList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof TasksApiTasksList
     */
    readonly pageSize?: number

    /**
     * A simple equality filter for the project_id field
     * @type {number}
     * @memberof TasksApiTasksList
     */
    readonly projectId?: number

    /**
     * A simple equality filter for the project_name field
     * @type {string}
     * @memberof TasksApiTasksList
     */
    readonly projectName?: string

    /**
     * A search term. Available search_fields: (\&#39;project_name\&#39;, \&#39;name\&#39;, \&#39;owner\&#39;, \&#39;status\&#39;, \&#39;assignee\&#39;, \&#39;subset\&#39;, \&#39;mode\&#39;, \&#39;dimension\&#39;, \&#39;tracker_link\&#39;, \&#39;validation_mode\&#39;)
     * @type {string}
     * @memberof TasksApiTasksList
     */
    readonly search?: string

    /**
     * Which field to use when ordering the results. Available ordering_fields: [\&#39;project_name\&#39;, \&#39;name\&#39;, \&#39;owner\&#39;, \&#39;status\&#39;, \&#39;assignee\&#39;, \&#39;subset\&#39;, \&#39;mode\&#39;, \&#39;dimension\&#39;, \&#39;tracker_link\&#39;, \&#39;validation_mode\&#39;, \&#39;id\&#39;, \&#39;project_id\&#39;, \&#39;updated_date\&#39;]
     * @type {string}
     * @memberof TasksApiTasksList
     */
    readonly sort?: string

    /**
     * A simple equality filter for the status field
     * @type {'annotation' | 'validation' | 'completed'}
     * @memberof TasksApiTasksList
     */
    readonly status?: TasksListStatusEnum

    /**
     * A simple equality filter for the subset field
     * @type {string}
     * @memberof TasksApiTasksList
     */
    readonly subset?: string

    /**
     * A simple equality filter for the tracker_link field
     * @type {string}
     * @memberof TasksApiTasksList
     */
    readonly trackerLink?: string

    /**
     * A simple equality filter for the validation_mode field
     * @type {'gt' | 'gt_pool'}
     * @memberof TasksApiTasksList
     */
    readonly validationMode?: TasksListValidationModeEnum
}

/**
 * Request parameters for tasksPartialUpdate operation in TasksApi.
 * @export
 * @interface TasksApiTasksPartialUpdateRequest
 */
export interface TasksApiTasksPartialUpdateRequest {
    /**
     * A unique integer value identifying this task.
     * @type {number}
     * @memberof TasksApiTasksPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {PatchedTaskWriteRequest}
     * @memberof TasksApiTasksPartialUpdate
     */
    readonly patchedTaskWriteRequest?: PatchedTaskWriteRequest
}

/**
 * Request parameters for tasksPartialUpdateAnnotations operation in TasksApi.
 * @export
 * @interface TasksApiTasksPartialUpdateAnnotationsRequest
 */
export interface TasksApiTasksPartialUpdateAnnotationsRequest {
    /**
     * 
     * @type {'create' | 'delete' | 'update'}
     * @memberof TasksApiTasksPartialUpdateAnnotations
     */
    readonly action: TasksPartialUpdateAnnotationsActionEnum

    /**
     * A unique integer value identifying this task.
     * @type {number}
     * @memberof TasksApiTasksPartialUpdateAnnotations
     */
    readonly id: number

    /**
     * 
     * @type {PatchedLabeledDataRequest}
     * @memberof TasksApiTasksPartialUpdateAnnotations
     */
    readonly patchedLabeledDataRequest?: PatchedLabeledDataRequest
}

/**
 * Request parameters for tasksPartialUpdateDataMeta operation in TasksApi.
 * @export
 * @interface TasksApiTasksPartialUpdateDataMetaRequest
 */
export interface TasksApiTasksPartialUpdateDataMetaRequest {
    /**
     * A unique integer value identifying this task.
     * @type {number}
     * @memberof TasksApiTasksPartialUpdateDataMeta
     */
    readonly id: number

    /**
     * 
     * @type {PatchedDataMetaWriteRequest}
     * @memberof TasksApiTasksPartialUpdateDataMeta
     */
    readonly patchedDataMetaWriteRequest?: PatchedDataMetaWriteRequest
}

/**
 * Request parameters for tasksPartialUpdateValidationLayout operation in TasksApi.
 * @export
 * @interface TasksApiTasksPartialUpdateValidationLayoutRequest
 */
export interface TasksApiTasksPartialUpdateValidationLayoutRequest {
    /**
     * A unique integer value identifying this task.
     * @type {number}
     * @memberof TasksApiTasksPartialUpdateValidationLayout
     */
    readonly id: number

    /**
     * 
     * @type {PatchedTaskValidationLayoutWriteRequest}
     * @memberof TasksApiTasksPartialUpdateValidationLayout
     */
    readonly patchedTaskValidationLayoutWriteRequest?: PatchedTaskValidationLayoutWriteRequest
}

/**
 * Request parameters for tasksRetrieve operation in TasksApi.
 * @export
 * @interface TasksApiTasksRetrieveRequest
 */
export interface TasksApiTasksRetrieveRequest {
    /**
     * A unique integer value identifying this task.
     * @type {number}
     * @memberof TasksApiTasksRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for tasksRetrieveAnnotations operation in TasksApi.
 * @export
 * @interface TasksApiTasksRetrieveAnnotationsRequest
 */
export interface TasksApiTasksRetrieveAnnotationsRequest {
    /**
     * A unique integer value identifying this task.
     * @type {number}
     * @memberof TasksApiTasksRetrieveAnnotations
     */
    readonly id: number

    /**
     * Used to start downloading process locally after annotation file has been created
     * @type {'download'}
     * @memberof TasksApiTasksRetrieveAnnotations
     */
    readonly action?: TasksRetrieveAnnotationsActionEnum

    /**
     * Storage id
     * @type {number}
     * @memberof TasksApiTasksRetrieveAnnotations
     */
    readonly cloudStorageId?: number

    /**
     * Desired output file name
     * @type {string}
     * @memberof TasksApiTasksRetrieveAnnotations
     */
    readonly filename?: string

    /**
     * Desired output format name You can get the list of supported formats at: /server/annotation/formats
     * @type {string}
     * @memberof TasksApiTasksRetrieveAnnotations
     */
    readonly format?: string

    /**
     * Where need to save downloaded dataset
     * @type {'cloud_storage' | 'local'}
     * @memberof TasksApiTasksRetrieveAnnotations
     */
    readonly location?: TasksRetrieveAnnotationsLocationEnum

    /**
     * Use the location that was configured in the task to export annotation
     * @type {boolean}
     * @memberof TasksApiTasksRetrieveAnnotations
     */
    readonly useDefaultLocation?: boolean
}

/**
 * Request parameters for tasksRetrieveBackup operation in TasksApi.
 * @export
 * @interface TasksApiTasksRetrieveBackupRequest
 */
export interface TasksApiTasksRetrieveBackupRequest {
    /**
     * A unique integer value identifying this task.
     * @type {number}
     * @memberof TasksApiTasksRetrieveBackup
     */
    readonly id: number

    /**
     * Used to start downloading process after backup file had been created
     * @type {'download'}
     * @memberof TasksApiTasksRetrieveBackup
     */
    readonly action?: TasksRetrieveBackupActionEnum

    /**
     * Storage id
     * @type {number}
     * @memberof TasksApiTasksRetrieveBackup
     */
    readonly cloudStorageId?: number

    /**
     * Backup file name
     * @type {string}
     * @memberof TasksApiTasksRetrieveBackup
     */
    readonly filename?: string

    /**
     * Where need to save downloaded backup
     * @type {'cloud_storage' | 'local'}
     * @memberof TasksApiTasksRetrieveBackup
     */
    readonly location?: TasksRetrieveBackupLocationEnum

    /**
     * Use the location that was configured in the task to export backup
     * @type {boolean}
     * @memberof TasksApiTasksRetrieveBackup
     */
    readonly useDefaultLocation?: boolean
}

/**
 * Request parameters for tasksRetrieveData operation in TasksApi.
 * @export
 * @interface TasksApiTasksRetrieveDataRequest
 */
export interface TasksApiTasksRetrieveDataRequest {
    /**
     * A unique integer value identifying this task.
     * @type {number}
     * @memberof TasksApiTasksRetrieveData
     */
    readonly id: number

    /**
     * A unique number value identifying chunk or frame
     * @type {number}
     * @memberof TasksApiTasksRetrieveData
     */
    readonly number?: number

    /**
     * Specifies the quality level of the requested data
     * @type {'compressed' | 'original'}
     * @memberof TasksApiTasksRetrieveData
     */
    readonly quality?: TasksRetrieveDataQualityEnum

    /**
     * Specifies the type of the requested data
     * @type {'chunk' | 'context_image' | 'frame'}
     * @memberof TasksApiTasksRetrieveData
     */
    readonly type?: TasksRetrieveDataTypeEnum
}

/**
 * Request parameters for tasksRetrieveDataMeta operation in TasksApi.
 * @export
 * @interface TasksApiTasksRetrieveDataMetaRequest
 */
export interface TasksApiTasksRetrieveDataMetaRequest {
    /**
     * A unique integer value identifying this task.
     * @type {number}
     * @memberof TasksApiTasksRetrieveDataMeta
     */
    readonly id: number
}

/**
 * Request parameters for tasksRetrieveDataset operation in TasksApi.
 * @export
 * @interface TasksApiTasksRetrieveDatasetRequest
 */
export interface TasksApiTasksRetrieveDatasetRequest {
    /**
     * Desired output format name You can get the list of supported formats at: /server/annotation/formats
     * @type {string}
     * @memberof TasksApiTasksRetrieveDataset
     */
    readonly format: string

    /**
     * A unique integer value identifying this task.
     * @type {number}
     * @memberof TasksApiTasksRetrieveDataset
     */
    readonly id: number

    /**
     * Used to start downloading process locally after annotation file has been created
     * @type {'download'}
     * @memberof TasksApiTasksRetrieveDataset
     */
    readonly action?: TasksRetrieveDatasetActionEnum

    /**
     * Storage id
     * @type {number}
     * @memberof TasksApiTasksRetrieveDataset
     */
    readonly cloudStorageId?: number

    /**
     * Desired output file name
     * @type {string}
     * @memberof TasksApiTasksRetrieveDataset
     */
    readonly filename?: string

    /**
     * Where need to save downloaded dataset
     * @type {'cloud_storage' | 'local'}
     * @memberof TasksApiTasksRetrieveDataset
     */
    readonly location?: TasksRetrieveDatasetLocationEnum

    /**
     * Use the location that was configured in task to export annotations
     * @type {boolean}
     * @memberof TasksApiTasksRetrieveDataset
     */
    readonly useDefaultLocation?: boolean
}

/**
 * Request parameters for tasksRetrievePreview operation in TasksApi.
 * @export
 * @interface TasksApiTasksRetrievePreviewRequest
 */
export interface TasksApiTasksRetrievePreviewRequest {
    /**
     * A unique integer value identifying this task.
     * @type {number}
     * @memberof TasksApiTasksRetrievePreview
     */
    readonly id: number
}

/**
 * Request parameters for tasksRetrieveStatus operation in TasksApi.
 * @export
 * @interface TasksApiTasksRetrieveStatusRequest
 */
export interface TasksApiTasksRetrieveStatusRequest {
    /**
     * A unique integer value identifying this task.
     * @type {number}
     * @memberof TasksApiTasksRetrieveStatus
     */
    readonly id: number
}

/**
 * Request parameters for tasksRetrieveValidationLayout operation in TasksApi.
 * @export
 * @interface TasksApiTasksRetrieveValidationLayoutRequest
 */
export interface TasksApiTasksRetrieveValidationLayoutRequest {
    /**
     * A unique integer value identifying this task.
     * @type {number}
     * @memberof TasksApiTasksRetrieveValidationLayout
     */
    readonly id: number
}

/**
 * Request parameters for tasksUpdateAnnotations operation in TasksApi.
 * @export
 * @interface TasksApiTasksUpdateAnnotationsRequest
 */
export interface TasksApiTasksUpdateAnnotationsRequest {
    /**
     * A unique integer value identifying this task.
     * @type {number}
     * @memberof TasksApiTasksUpdateAnnotations
     */
    readonly id: number

    /**
     * Input format name You can get the list of supported formats at: /server/annotation/formats
     * @type {string}
     * @memberof TasksApiTasksUpdateAnnotations
     */
    readonly format?: string

    /**
     * rq id
     * @type {string}
     * @memberof TasksApiTasksUpdateAnnotations
     */
    readonly rqId?: string

    /**
     * 
     * @type {TaskAnnotationsUpdateRequest}
     * @memberof TasksApiTasksUpdateAnnotations
     */
    readonly taskAnnotationsUpdateRequest?: TaskAnnotationsUpdateRequest | null
}

/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
export class TasksApi extends BaseAPI {
    /**
     * The new task will not have any attached images or videos. To attach them, use the /api/tasks/<id>/data endpoint. 
     * @summary Create a task
     * @param {TasksApiTasksCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksCreate(requestParameters: TasksApiTasksCreateRequest, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksCreate(requestParameters.taskWriteRequest, requestParameters.xOrganization, requestParameters.org, requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  The request POST /api/tasks/id/annotations will initiate the import and will create the rq job on the server in which the import will be carried out. Please, use the PUT /api/tasks/id/annotations endpoint for checking status of the process. 
     * @summary Import annotations into a task
     * @param {TasksApiTasksCreateAnnotationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksCreateAnnotations(requestParameters: TasksApiTasksCreateAnnotationsRequest, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksCreateAnnotations(requestParameters.id, requestParameters.cloudStorageId, requestParameters.filename, requestParameters.format, requestParameters.location, requestParameters.useDefaultLocation, requestParameters.taskAnnotationsWriteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  The backup import process is as follows:  The first request POST /api/tasks/backup will initiate file upload and will create the rq job on the server in which the process of a task creating from an uploaded backup will be carried out.  After initiating the backup upload, you will receive an rq_id parameter. Make sure to include this parameter as a query parameter in your subsequent requests to track the status of the task creation. Once the task has been successfully created, the server will return the id of the newly created task. 
     * @summary Recreate a task from a backup
     * @param {TasksApiTasksCreateBackupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksCreateBackup(requestParameters: TasksApiTasksCreateBackupRequest = {}, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksCreateBackup(requestParameters.xOrganization, requestParameters.cloudStorageId, requestParameters.filename, requestParameters.location, requestParameters.org, requestParameters.orgId, requestParameters.rqId, requestParameters.taskFileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The request `POST /api/<projects|tasks>/id/backup/export` will initialize a background process to backup a resource. To check status of the process please, use `GET /api/requests/<rq_id>` where **rq_id** is request ID returned in the response for this endpoint. 
     * @summary Initiate process to backup resource
     * @param {TasksApiTasksCreateBackupExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksCreateBackupExport(requestParameters: TasksApiTasksCreateBackupExportRequest, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksCreateBackupExport(requestParameters.id, requestParameters.cloudStorageId, requestParameters.filename, requestParameters.location, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows to upload data (images, video, etc.) to a task. Supports the TUS open file uploading protocol (https://tus.io/).  Supports the following protocols:  1. A single Data request  and  2.1. An Upload-Start request 2.2.a. Regular TUS protocol requests (Upload-Length + Chunks) 2.2.b. Upload-Multiple requests 2.3. An Upload-Finish request  Requests: - Data - POST, no extra headers or \'Upload-Start\' + \'Upload-Finish\' headers.   Contains data in the body. - Upload-Start - POST, has an \'Upload-Start\' header. No body is expected. - Upload-Length - POST, has an \'Upload-Length\' header (see the TUS specification) - Chunk - HEAD/PATCH (see the TUS specification). Sent to /data/<file id> endpoints. - Upload-Finish - POST, has an \'Upload-Finish\' header. Can contain data in the body. - Upload-Multiple - POST, has an \'Upload-Multiple\' header. Contains data in the body.  The \'Upload-Finish\' request allows to specify the uploaded files should be ordered. This may be needed if the files can be sent unordered. To state that the input files are sent ordered, pass an empty list of files in the \'upload_file_order\' field. If the files are sent unordered, the ordered file list is expected in the \'upload_file_order\' field. It must be a list of string file paths, relative to the dataset root.  Example: files = [     \"cats/cat_1.jpg\",     \"dogs/dog2.jpg\",     \"image_3.png\",     ... ]  Independently of the file declaration field used (\'client_files\', \'server_files\', etc.), when the \'predefined\' sorting method is selected, the uploaded files will be ordered according to the \'.jsonl\' manifest file, if it is found in the list of files. For archives (e.g. \'.zip\'), a manifest file (\'*.jsonl\') is required when using the \'predefined\' file ordering. Such file must be provided next to the archive in the list of files. Read more about manifest files here: https://docs.cvat.ai/docs/manual/advanced/dataset_manifest/  After all data is sent, the operation status can be retrieved via the `GET /api/requests/<rq_id>`, where **rq_id** is request ID returned for this request.  Once data is attached to a task, it cannot be detached or replaced. 
     * @summary Attach data to a task
     * @param {TasksApiTasksCreateDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksCreateData(requestParameters: TasksApiTasksCreateDataRequest, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksCreateData(requestParameters.id, requestParameters.uploadFinish, requestParameters.uploadMultiple, requestParameters.uploadStart, requestParameters.dataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The request `POST /api/<projects|tasks|jobs>/id/dataset/export` will initialize a background process to export a dataset. To check status of the process please, use `GET /api/requests/<rq_id>` where **rq_id** is request ID returned in the response for this endpoint. 
     * @summary Initialize process to export resource as a dataset in a specific format
     * @param {TasksApiTasksCreateDatasetExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksCreateDatasetExport(requestParameters: TasksApiTasksCreateDatasetExportRequest, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksCreateDatasetExport(requestParameters.format, requestParameters.id, requestParameters.cloudStorageId, requestParameters.filename, requestParameters.location, requestParameters.saveImages, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * All attached jobs, annotations and data will be deleted as well.
     * @summary Delete a task
     * @param {TasksApiTasksDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksDestroy(requestParameters: TasksApiTasksDestroyRequest, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete task annotations
     * @param {TasksApiTasksDestroyAnnotationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksDestroyAnnotations(requestParameters: TasksApiTasksDestroyAnnotationsRequest, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksDestroyAnnotations(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List tasks
     * @param {TasksApiTasksListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksList(requestParameters: TasksApiTasksListRequest = {}, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksList(requestParameters.xOrganization, requestParameters.assignee, requestParameters.dimension, requestParameters.filter, requestParameters.mode, requestParameters.name, requestParameters.org, requestParameters.orgId, requestParameters.owner, requestParameters.page, requestParameters.pageSize, requestParameters.projectId, requestParameters.projectName, requestParameters.search, requestParameters.sort, requestParameters.status, requestParameters.subset, requestParameters.trackerLink, requestParameters.validationMode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a task
     * @param {TasksApiTasksPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksPartialUpdate(requestParameters: TasksApiTasksPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksPartialUpdate(requestParameters.id, requestParameters.patchedTaskWriteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update task annotations
     * @param {TasksApiTasksPartialUpdateAnnotationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksPartialUpdateAnnotations(requestParameters: TasksApiTasksPartialUpdateAnnotationsRequest, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksPartialUpdateAnnotations(requestParameters.action, requestParameters.id, requestParameters.patchedLabeledDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update metainformation for media files in a task
     * @param {TasksApiTasksPartialUpdateDataMetaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksPartialUpdateDataMeta(requestParameters: TasksApiTasksPartialUpdateDataMetaRequest, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksPartialUpdateDataMeta(requestParameters.id, requestParameters.patchedDataMetaWriteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  WARNING: this operation is not protected from race conditions. It\'s up to the user to ensure no parallel calls to this operation happen. It affects image access, including exports with images, backups, chunk downloading etc. 
     * @summary Allows updating current validation configuration
     * @param {TasksApiTasksPartialUpdateValidationLayoutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksPartialUpdateValidationLayout(requestParameters: TasksApiTasksPartialUpdateValidationLayoutRequest, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksPartialUpdateValidationLayout(requestParameters.id, requestParameters.patchedTaskValidationLayoutWriteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get task details
     * @param {TasksApiTasksRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksRetrieve(requestParameters: TasksApiTasksRetrieveRequest, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deprecation warning:  Utilizing this endpoint ot export annotations as a dataset in a specific format will be deprecated in one of the next releases.  Consider using new API: - POST /api/tasks/<task_id>/dataset/export?save_images=False to initiate export process - GET /api/requests/<rq_id> to check process status,     where rq_id is request id returned on initializing request 
     * @summary Get task annotations or export them as a dataset in a specific format
     * @param {TasksApiTasksRetrieveAnnotationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksRetrieveAnnotations(requestParameters: TasksApiTasksRetrieveAnnotationsRequest, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksRetrieveAnnotations(requestParameters.id, requestParameters.action, requestParameters.cloudStorageId, requestParameters.filename, requestParameters.format, requestParameters.location, requestParameters.useDefaultLocation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deprecation warning:     This endpoint will be deprecated in one of the next releases.     Consider using new API:     - POST /api/tasks/<task_id>/backup/export to initiate backup process     - GET /api/requests/<rq_id> to check process status,         where rq_id is request id returned on initializing request\' 
     * @summary Back up a task
     * @param {TasksApiTasksRetrieveBackupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksRetrieveBackup(requestParameters: TasksApiTasksRetrieveBackupRequest, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksRetrieveBackup(requestParameters.id, requestParameters.action, requestParameters.cloudStorageId, requestParameters.filename, requestParameters.location, requestParameters.useDefaultLocation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get data of a task
     * @param {TasksApiTasksRetrieveDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksRetrieveData(requestParameters: TasksApiTasksRetrieveDataRequest, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksRetrieveData(requestParameters.id, requestParameters.number, requestParameters.quality, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get metainformation for media files in a task
     * @param {TasksApiTasksRetrieveDataMetaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksRetrieveDataMeta(requestParameters: TasksApiTasksRetrieveDataMetaRequest, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksRetrieveDataMeta(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deprecation warning:  Utilizing this endpoint to export task dataset in a specific format will be deprecated in one of the next releases.  Consider using new API: - POST /api/tasks/<task_id>/dataset/export?save_images=True to initiate export process - GET /api/requests/<rq_id> to check process status,     where rq_id is request id returned on initializing request 
     * @summary Export task as a dataset in a specific format
     * @param {TasksApiTasksRetrieveDatasetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksRetrieveDataset(requestParameters: TasksApiTasksRetrieveDatasetRequest, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksRetrieveDataset(requestParameters.format, requestParameters.id, requestParameters.action, requestParameters.cloudStorageId, requestParameters.filename, requestParameters.location, requestParameters.useDefaultLocation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a preview image for a task
     * @param {TasksApiTasksRetrievePreviewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksRetrievePreview(requestParameters: TasksApiTasksRetrievePreviewRequest, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksRetrievePreview(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method is deprecated and will be removed in one of the next releases. To check status of task creation, use new common API for managing background operations: GET /api/requests/?action=create&task_id=<task_id>
     * @summary Get the creation status of a task
     * @param {TasksApiTasksRetrieveStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksRetrieveStatus(requestParameters: TasksApiTasksRetrieveStatusRequest, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksRetrieveStatus(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Allows getting current validation configuration
     * @param {TasksApiTasksRetrieveValidationLayoutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksRetrieveValidationLayout(requestParameters: TasksApiTasksRetrieveValidationLayoutRequest, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksRetrieveValidationLayout(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  To check the status of an import request:  After initiating the annotation import, you will receive an rq_id parameter. Make sure to include this parameter as a query parameter in your subsequent PUT /api/tasks/id/annotations requests to track the status of the import. 
     * @summary Replace task annotations / Get annotation import status
     * @param {TasksApiTasksUpdateAnnotationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksUpdateAnnotations(requestParameters: TasksApiTasksUpdateAnnotationsRequest, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksUpdateAnnotations(requestParameters.id, requestParameters.format, requestParameters.rqId, requestParameters.taskAnnotationsUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const TasksCreateAnnotationsLocationEnum = {
    CloudStorage: 'cloud_storage',
    Local: 'local'
} as const;
export type TasksCreateAnnotationsLocationEnum = typeof TasksCreateAnnotationsLocationEnum[keyof typeof TasksCreateAnnotationsLocationEnum];
/**
 * @export
 */
export const TasksCreateBackupLocationEnum = {
    CloudStorage: 'cloud_storage',
    Local: 'local'
} as const;
export type TasksCreateBackupLocationEnum = typeof TasksCreateBackupLocationEnum[keyof typeof TasksCreateBackupLocationEnum];
/**
 * @export
 */
export const TasksCreateBackupExportLocationEnum = {
    CloudStorage: 'cloud_storage',
    Local: 'local'
} as const;
export type TasksCreateBackupExportLocationEnum = typeof TasksCreateBackupExportLocationEnum[keyof typeof TasksCreateBackupExportLocationEnum];
/**
 * @export
 */
export const TasksCreateDatasetExportLocationEnum = {
    CloudStorage: 'cloud_storage',
    Local: 'local'
} as const;
export type TasksCreateDatasetExportLocationEnum = typeof TasksCreateDatasetExportLocationEnum[keyof typeof TasksCreateDatasetExportLocationEnum];
/**
 * @export
 */
export const TasksListDimensionEnum = {
    _3d: '3d',
    _2d: '2d'
} as const;
export type TasksListDimensionEnum = typeof TasksListDimensionEnum[keyof typeof TasksListDimensionEnum];
/**
 * @export
 */
export const TasksListStatusEnum = {
    Annotation: 'annotation',
    Validation: 'validation',
    Completed: 'completed'
} as const;
export type TasksListStatusEnum = typeof TasksListStatusEnum[keyof typeof TasksListStatusEnum];
/**
 * @export
 */
export const TasksListValidationModeEnum = {
    Gt: 'gt',
    GtPool: 'gt_pool'
} as const;
export type TasksListValidationModeEnum = typeof TasksListValidationModeEnum[keyof typeof TasksListValidationModeEnum];
/**
 * @export
 */
export const TasksPartialUpdateAnnotationsActionEnum = {
    Create: 'create',
    Delete: 'delete',
    Update: 'update'
} as const;
export type TasksPartialUpdateAnnotationsActionEnum = typeof TasksPartialUpdateAnnotationsActionEnum[keyof typeof TasksPartialUpdateAnnotationsActionEnum];
/**
 * @export
 */
export const TasksRetrieveAnnotationsActionEnum = {
    Download: 'download'
} as const;
export type TasksRetrieveAnnotationsActionEnum = typeof TasksRetrieveAnnotationsActionEnum[keyof typeof TasksRetrieveAnnotationsActionEnum];
/**
 * @export
 */
export const TasksRetrieveAnnotationsLocationEnum = {
    CloudStorage: 'cloud_storage',
    Local: 'local'
} as const;
export type TasksRetrieveAnnotationsLocationEnum = typeof TasksRetrieveAnnotationsLocationEnum[keyof typeof TasksRetrieveAnnotationsLocationEnum];
/**
 * @export
 */
export const TasksRetrieveBackupActionEnum = {
    Download: 'download'
} as const;
export type TasksRetrieveBackupActionEnum = typeof TasksRetrieveBackupActionEnum[keyof typeof TasksRetrieveBackupActionEnum];
/**
 * @export
 */
export const TasksRetrieveBackupLocationEnum = {
    CloudStorage: 'cloud_storage',
    Local: 'local'
} as const;
export type TasksRetrieveBackupLocationEnum = typeof TasksRetrieveBackupLocationEnum[keyof typeof TasksRetrieveBackupLocationEnum];
/**
 * @export
 */
export const TasksRetrieveDataQualityEnum = {
    Compressed: 'compressed',
    Original: 'original'
} as const;
export type TasksRetrieveDataQualityEnum = typeof TasksRetrieveDataQualityEnum[keyof typeof TasksRetrieveDataQualityEnum];
/**
 * @export
 */
export const TasksRetrieveDataTypeEnum = {
    Chunk: 'chunk',
    ContextImage: 'context_image',
    Frame: 'frame'
} as const;
export type TasksRetrieveDataTypeEnum = typeof TasksRetrieveDataTypeEnum[keyof typeof TasksRetrieveDataTypeEnum];
/**
 * @export
 */
export const TasksRetrieveDatasetActionEnum = {
    Download: 'download'
} as const;
export type TasksRetrieveDatasetActionEnum = typeof TasksRetrieveDatasetActionEnum[keyof typeof TasksRetrieveDatasetActionEnum];
/**
 * @export
 */
export const TasksRetrieveDatasetLocationEnum = {
    CloudStorage: 'cloud_storage',
    Local: 'local'
} as const;
export type TasksRetrieveDatasetLocationEnum = typeof TasksRetrieveDatasetLocationEnum[keyof typeof TasksRetrieveDatasetLocationEnum];
