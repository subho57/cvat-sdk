/* tslint:disable */
/* eslint-disable */
/**
 * CVAT REST API
 * REST API for Computer Vision Annotation Tool (CVAT)
 *
 * The version of the OpenAPI document: 2.5.1
 * Contact: support@cvat.ai
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AnnotationsRead } from '../models';
// @ts-ignore
import { DataMetaRead } from '../models';
// @ts-ignore
import { DataRequest } from '../models';
// @ts-ignore
import { LabeledData } from '../models';
// @ts-ignore
import { PaginatedTaskReadList } from '../models';
// @ts-ignore
import { PatchedDataMetaWriteRequest } from '../models';
// @ts-ignore
import { PatchedLabeledDataRequest } from '../models';
// @ts-ignore
import { PatchedTaskWriteRequest } from '../models';
// @ts-ignore
import { RqId } from '../models';
// @ts-ignore
import { RqStatus } from '../models';
// @ts-ignore
import { TaskAnnotationsUpdateRequest } from '../models';
// @ts-ignore
import { TaskAnnotationsWriteRequest } from '../models';
// @ts-ignore
import { TaskFileRequest } from '../models';
// @ts-ignore
import { TaskRead } from '../models';
// @ts-ignore
import { TaskWriteRequest } from '../models';
/**
 * TasksApi - axios parameter creator
 * @export
 */
export const TasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Method provides a meta information about media files which are related with the job
         * @param {number} id A unique integer value identifying this job.
         * @param {PatchedDataMetaWriteRequest} [patchedDataMetaWriteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsPartialUpdateDataMeta: async (id: number, patchedDataMetaWriteRequest?: PatchedDataMetaWriteRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('jobsPartialUpdateDataMeta', 'id', id)
            const localVarPath = `/api/jobs/{id}/data/meta`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedDataMetaWriteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Method creates a new task in a database without any attached images and videos
         * @param {TaskWriteRequest} taskWriteRequest 
         * @param {string} [xOrganization] Organization unique slug
         * @param {string} [org] Organization unique slug
         * @param {number} [orgId] Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksCreate: async (taskWriteRequest: TaskWriteRequest, xOrganization?: string, org?: string, orgId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskWriteRequest' is not null or undefined
            assertParamExists('tasksCreate', 'taskWriteRequest', taskWriteRequest)
            const localVarPath = `/api/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['org_id'] = orgId;
            }

            if (xOrganization != null) {
                localVarHeaderParameter['X-Organization'] = String(xOrganization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taskWriteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  The request POST /api/tasks/id/annotations will initiate file upload and will create the rq job on the server in which the process of annotations uploading from file will be carried out. Please, use the PUT /api/tasks/id/annotations endpoint for checking status of the process. 
         * @summary Method allows to initialize the  process of upload task annotations from a local or a cloud storage file
         * @param {number} id A unique integer value identifying this task.
         * @param {number} [cloudStorageId] Storage id
         * @param {string} [filename] Annotation file name
         * @param {string} [format] Input format name You can get the list of supported formats at: /server/annotation/formats
         * @param {TasksCreateAnnotationsLocationEnum} [location] where to import the annotation from
         * @param {boolean} [useDefaultLocation] Use the location that was configured in task to import annotations
         * @param {TaskAnnotationsWriteRequest | null} [taskAnnotationsWriteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksCreateAnnotations: async (id: number, cloudStorageId?: number, filename?: string, format?: string, location?: TasksCreateAnnotationsLocationEnum, useDefaultLocation?: boolean, taskAnnotationsWriteRequest?: TaskAnnotationsWriteRequest | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksCreateAnnotations', 'id', id)
            const localVarPath = `/api/tasks/{id}/annotations/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required

            if (cloudStorageId !== undefined) {
                localVarQueryParameter['cloud_storage_id'] = cloudStorageId;
            }

            if (filename !== undefined) {
                localVarQueryParameter['filename'] = filename;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }

            if (useDefaultLocation !== undefined) {
                localVarQueryParameter['use_default_location'] = useDefaultLocation;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taskAnnotationsWriteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  The backup import process is as follows:  The first request POST /api/tasks/backup will initiate file upload and will create the rq job on the server in which the process of a task creating from an uploaded backup will be carried out.  After initiating the backup upload, you will receive an rq_id parameter. Make sure to include this parameter as a query parameter in your subsequent requests to track the status of the task creation. Once the task has been successfully created, the server will return the id of the newly created task. 
         * @summary Method recreates a task from an attached task backup file
         * @param {string} [xOrganization] Organization unique slug
         * @param {number} [cloudStorageId] Storage id
         * @param {string} [filename] Backup file name
         * @param {TasksCreateBackupLocationEnum} [location] Where to import the backup file from
         * @param {string} [org] Organization unique slug
         * @param {number} [orgId] Organization identifier
         * @param {string} [rqId] rq id
         * @param {TaskFileRequest} [taskFileRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksCreateBackup: async (xOrganization?: string, cloudStorageId?: number, filename?: string, location?: TasksCreateBackupLocationEnum, org?: string, orgId?: number, rqId?: string, taskFileRequest?: TaskFileRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tasks/backup/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required

            if (cloudStorageId !== undefined) {
                localVarQueryParameter['cloud_storage_id'] = cloudStorageId;
            }

            if (filename !== undefined) {
                localVarQueryParameter['filename'] = filename;
            }

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['org_id'] = orgId;
            }

            if (rqId !== undefined) {
                localVarQueryParameter['rq_id'] = rqId;
            }

            if (xOrganization != null) {
                localVarHeaderParameter['X-Organization'] = String(xOrganization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taskFileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows to upload data to a task. Supports the TUS open file uploading protocol (https://tus.io/).  Supports the following protocols:  1. A single Data request  and  2.1. An Upload-Start request 2.2.a. Regular TUS protocol requests (Upload-Length + Chunks) 2.2.b. Upload-Multiple requests 2.3. An Upload-Finish request  Requests: - Data - POST, no extra headers or \'Upload-Start\' + \'Upload-Finish\' headers.   Contains data in the body. - Upload-Start - POST, has an \'Upload-Start\' header. No body is expected. - Upload-Length - POST, has an \'Upload-Length\' header (see the TUS specification) - Chunk - HEAD/PATCH (see the TUS specification). Sent to /data/<file id> endpoints. - Upload-Finish - POST, has an \'Upload-Finish\' header. Can contain data in the body. - Upload-Multiple - POST, has an \'Upload-Multiple\' header. Contains data in the body.  The \'Upload-Finish\' request allows to specify the uploaded files should be ordered. This may be needed if the files can be sent unordered. To state that the input files are sent ordered, pass an empty list of files in the \'upload_file_order\' field. If the files are sent unordered, the ordered file list is expected in the \'upload_file_order\' field. It must be a list of string file paths, relative to the dataset root.  Example: files = [     \"cats/cat_1.jpg\",     \"dogs/dog2.jpg\",     \"image_3.png\",     ... ]  Independently of the file declaration field used (\'client_files\', \'server_files\', etc.), when the \'predefined\' sorting method is selected, the uploaded files will be ordered according to the \'.jsonl\' manifest file, if it is found in the list of files. For archives (e.g. \'.zip\'), a manifest file (\'*.jsonl\') is required when using the \'predefined\' file ordering. Such file must be provided next to the archive in the list of files. Read more about manifest files here: https://opencv.github.io/cvat/docs/manual/advanced/dataset_manifest/  After all data is sent, the operation status can be retrieved via the /status endpoint. 
         * @summary Method permanently attaches data (images, video, etc.) to a task
         * @param {number} id A unique integer value identifying this task.
         * @param {boolean} [uploadFinish] Finishes data upload. Can be combined with Upload-Start header to create task data with one request
         * @param {boolean} [uploadMultiple] Indicates that data with this request are single or multiple files that should be attached to a task
         * @param {boolean} [uploadStart] Initializes data upload. Optionally, can include upload metadata in the request body.
         * @param {DataRequest} [dataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksCreateData: async (id: number, uploadFinish?: boolean, uploadMultiple?: boolean, uploadStart?: boolean, dataRequest?: DataRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksCreateData', 'id', id)
            const localVarPath = `/api/tasks/{id}/data/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required

            if (uploadFinish != null) {
                localVarHeaderParameter['Upload-Finish'] = typeof uploadFinish === 'string'
                    ? uploadFinish
                    : JSON.stringify(uploadFinish);
            }

            if (uploadMultiple != null) {
                localVarHeaderParameter['Upload-Multiple'] = typeof uploadMultiple === 'string'
                    ? uploadMultiple
                    : JSON.stringify(uploadMultiple);
            }

            if (uploadStart != null) {
                localVarHeaderParameter['Upload-Start'] = typeof uploadStart === 'string'
                    ? uploadStart
                    : JSON.stringify(uploadStart);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Method deletes a specific task, all attached jobs, annotations, and data
         * @param {number} id A unique integer value identifying this task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksDestroy', 'id', id)
            const localVarPath = `/api/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Method deletes all annotations for a specific task
         * @param {number} id A unique integer value identifying this task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksDestroyAnnotations: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksDestroyAnnotations', 'id', id)
            const localVarPath = `/api/tasks/{id}/annotations/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a paginated list of tasks
         * @param {string} [xOrganization] Organization unique slug
         * @param {string} [assignee] A simple equality filter for the assignee field
         * @param {TasksListDimensionEnum} [dimension] A simple equality filter for the dimension field
         * @param {string} [filter] A filter term. Available filter_fields: [\&#39;project_name\&#39;, \&#39;name\&#39;, \&#39;owner\&#39;, \&#39;status\&#39;, \&#39;assignee\&#39;, \&#39;subset\&#39;, \&#39;mode\&#39;, \&#39;dimension\&#39;, \&#39;tracker_link\&#39;, \&#39;id\&#39;, \&#39;project_id\&#39;, \&#39;updated_date\&#39;]
         * @param {string} [mode] A simple equality filter for the mode field
         * @param {string} [name] A simple equality filter for the name field
         * @param {string} [org] Organization unique slug
         * @param {number} [orgId] Organization identifier
         * @param {string} [owner] A simple equality filter for the owner field
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [projectId] A simple equality filter for the project_id field
         * @param {string} [projectName] A simple equality filter for the project_name field
         * @param {string} [search] A search term. Available search_fields: (\&#39;project_name\&#39;, \&#39;name\&#39;, \&#39;owner\&#39;, \&#39;status\&#39;, \&#39;assignee\&#39;, \&#39;subset\&#39;, \&#39;mode\&#39;, \&#39;dimension\&#39;, \&#39;tracker_link\&#39;)
         * @param {string} [sort] Which field to use when ordering the results. Available ordering_fields: [\&#39;project_name\&#39;, \&#39;name\&#39;, \&#39;owner\&#39;, \&#39;status\&#39;, \&#39;assignee\&#39;, \&#39;subset\&#39;, \&#39;mode\&#39;, \&#39;dimension\&#39;, \&#39;tracker_link\&#39;, \&#39;id\&#39;, \&#39;project_id\&#39;, \&#39;updated_date\&#39;]
         * @param {TasksListStatusEnum} [status] A simple equality filter for the status field
         * @param {string} [subset] A simple equality filter for the subset field
         * @param {string} [trackerLink] A simple equality filter for the tracker_link field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksList: async (xOrganization?: string, assignee?: string, dimension?: TasksListDimensionEnum, filter?: string, mode?: string, name?: string, org?: string, orgId?: number, owner?: string, page?: number, pageSize?: number, projectId?: number, projectName?: string, search?: string, sort?: string, status?: TasksListStatusEnum, subset?: string, trackerLink?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required

            if (assignee !== undefined) {
                localVarQueryParameter['assignee'] = assignee;
            }

            if (dimension !== undefined) {
                localVarQueryParameter['dimension'] = dimension;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['org_id'] = orgId;
            }

            if (owner !== undefined) {
                localVarQueryParameter['owner'] = owner;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (projectName !== undefined) {
                localVarQueryParameter['project_name'] = projectName;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (subset !== undefined) {
                localVarQueryParameter['subset'] = subset;
            }

            if (trackerLink !== undefined) {
                localVarQueryParameter['tracker_link'] = trackerLink;
            }

            if (xOrganization != null) {
                localVarHeaderParameter['X-Organization'] = String(xOrganization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Methods does a partial update of chosen fields in a task
         * @param {number} id A unique integer value identifying this task.
         * @param {PatchedTaskWriteRequest} [patchedTaskWriteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksPartialUpdate: async (id: number, patchedTaskWriteRequest?: PatchedTaskWriteRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksPartialUpdate', 'id', id)
            const localVarPath = `/api/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedTaskWriteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Method performs a partial update of annotations in a specific task
         * @param {TasksPartialUpdateAnnotationsActionEnum} action 
         * @param {number} id A unique integer value identifying this task.
         * @param {PatchedLabeledDataRequest} [patchedLabeledDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksPartialUpdateAnnotations: async (action: TasksPartialUpdateAnnotationsActionEnum, id: number, patchedLabeledDataRequest?: PatchedLabeledDataRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'action' is not null or undefined
            assertParamExists('tasksPartialUpdateAnnotations', 'action', action)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksPartialUpdateAnnotations', 'id', id)
            const localVarPath = `/api/tasks/{id}/annotations/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedLabeledDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Method provides a meta information about media files which are related with the task
         * @param {number} id A unique integer value identifying this task.
         * @param {PatchedDataMetaWriteRequest} [patchedDataMetaWriteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksPartialUpdateDataMeta: async (id: number, patchedDataMetaWriteRequest?: PatchedDataMetaWriteRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksPartialUpdateDataMeta', 'id', id)
            const localVarPath = `/api/tasks/{id}/data/meta`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedDataMetaWriteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Method returns details of a specific task
         * @param {number} id A unique integer value identifying this task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksRetrieve', 'id', id)
            const localVarPath = `/api/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Method allows to download task annotations
         * @param {number} id A unique integer value identifying this task.
         * @param {TasksRetrieveAnnotationsActionEnum} [action] Used to start downloading process after annotation file had been created
         * @param {number} [cloudStorageId] Storage id
         * @param {string} [filename] Desired output file name
         * @param {string} [format] Desired output format name You can get the list of supported formats at: /server/annotation/formats
         * @param {TasksRetrieveAnnotationsLocationEnum} [location] Where need to save downloaded dataset
         * @param {boolean} [useDefaultLocation] Use the location that was configured in the task to export annotation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksRetrieveAnnotations: async (id: number, action?: TasksRetrieveAnnotationsActionEnum, cloudStorageId?: number, filename?: string, format?: string, location?: TasksRetrieveAnnotationsLocationEnum, useDefaultLocation?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksRetrieveAnnotations', 'id', id)
            const localVarPath = `/api/tasks/{id}/annotations/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }

            if (cloudStorageId !== undefined) {
                localVarQueryParameter['cloud_storage_id'] = cloudStorageId;
            }

            if (filename !== undefined) {
                localVarQueryParameter['filename'] = filename;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }

            if (useDefaultLocation !== undefined) {
                localVarQueryParameter['use_default_location'] = useDefaultLocation;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Method backup a specified task
         * @param {number} id A unique integer value identifying this task.
         * @param {TasksRetrieveBackupActionEnum} [action] Used to start downloading process after backup file had been created
         * @param {number} [cloudStorageId] Storage id
         * @param {string} [filename] Backup file name
         * @param {TasksRetrieveBackupLocationEnum} [location] Where need to save downloaded backup
         * @param {boolean} [useDefaultLocation] Use the location that was configured in the task to export backup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksRetrieveBackup: async (id: number, action?: TasksRetrieveBackupActionEnum, cloudStorageId?: number, filename?: string, location?: TasksRetrieveBackupLocationEnum, useDefaultLocation?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksRetrieveBackup', 'id', id)
            const localVarPath = `/api/tasks/{id}/backup`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }

            if (cloudStorageId !== undefined) {
                localVarQueryParameter['cloud_storage_id'] = cloudStorageId;
            }

            if (filename !== undefined) {
                localVarQueryParameter['filename'] = filename;
            }

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }

            if (useDefaultLocation !== undefined) {
                localVarQueryParameter['use_default_location'] = useDefaultLocation;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Method returns data for a specific task
         * @param {number} id A unique integer value identifying this task.
         * @param {number} [number] A unique number value identifying chunk or frame
         * @param {TasksRetrieveDataQualityEnum} [quality] Specifies the quality level of the requested data
         * @param {TasksRetrieveDataTypeEnum} [type] Specifies the type of the requested data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksRetrieveData: async (id: number, number?: number, quality?: TasksRetrieveDataQualityEnum, type?: TasksRetrieveDataTypeEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksRetrieveData', 'id', id)
            const localVarPath = `/api/tasks/{id}/data/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required

            if (number !== undefined) {
                localVarQueryParameter['number'] = number;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Method provides a meta information about media files which are related with the task
         * @param {number} id A unique integer value identifying this task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksRetrieveDataMeta: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksRetrieveDataMeta', 'id', id)
            const localVarPath = `/api/tasks/{id}/data/meta`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Export task as a dataset in a specific format
         * @param {string} format Desired output format name You can get the list of supported formats at: /server/annotation/formats
         * @param {number} id A unique integer value identifying this task.
         * @param {TasksRetrieveDatasetActionEnum} [action] Used to start downloading process after annotation file had been created
         * @param {number} [cloudStorageId] Storage id
         * @param {string} [filename] Desired output file name
         * @param {TasksRetrieveDatasetLocationEnum} [location] Where need to save downloaded dataset
         * @param {boolean} [useDefaultLocation] Use the location that was configured in task to export annotations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksRetrieveDataset: async (format: string, id: number, action?: TasksRetrieveDatasetActionEnum, cloudStorageId?: number, filename?: string, location?: TasksRetrieveDatasetLocationEnum, useDefaultLocation?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'format' is not null or undefined
            assertParamExists('tasksRetrieveDataset', 'format', format)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksRetrieveDataset', 'id', id)
            const localVarPath = `/api/tasks/{id}/dataset`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }

            if (cloudStorageId !== undefined) {
                localVarQueryParameter['cloud_storage_id'] = cloudStorageId;
            }

            if (filename !== undefined) {
                localVarQueryParameter['filename'] = filename;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }

            if (useDefaultLocation !== undefined) {
                localVarQueryParameter['use_default_location'] = useDefaultLocation;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Method returns a preview image for the task
         * @param {number} id A unique integer value identifying this task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksRetrievePreview: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksRetrievePreview', 'id', id)
            const localVarPath = `/api/tasks/{id}/preview`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary When task is being created the method returns information about a status of the creation process
         * @param {number} id A unique integer value identifying this task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksRetrieveStatus: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksRetrieveStatus', 'id', id)
            const localVarPath = `/api/tasks/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  To check the status of the process of uploading a task annotations from a file:  After initiating the annotations upload, you will receive an rq_id parameter. Make sure to include this parameter as a query parameter in your subsequent PUT /api/tasks/id/annotations requests to track the status of the annotations upload. 
         * @summary Method allows to upload task annotations or edit existing annotations
         * @param {number} id A unique integer value identifying this task.
         * @param {string} [format] Input format name You can get the list of supported formats at: /server/annotation/formats
         * @param {string} [rqId] rq id
         * @param {TaskAnnotationsUpdateRequest | null} [taskAnnotationsUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksUpdateAnnotations: async (id: number, format?: string, rqId?: string, taskAnnotationsUpdateRequest?: TaskAnnotationsUpdateRequest | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksUpdateAnnotations', 'id', id)
            const localVarPath = `/api/tasks/{id}/annotations/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication signatureAuth required
            await setApiKeyToObject(localVarQueryParameter, "sign", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication tokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication csrfAuth required

            // authentication sessionAuth required

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (rqId !== undefined) {
                localVarQueryParameter['rq_id'] = rqId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taskAnnotationsUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TasksApi - functional programming interface
 * @export
 */
export const TasksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TasksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Method provides a meta information about media files which are related with the job
         * @param {number} id A unique integer value identifying this job.
         * @param {PatchedDataMetaWriteRequest} [patchedDataMetaWriteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jobsPartialUpdateDataMeta(id: number, patchedDataMetaWriteRequest?: PatchedDataMetaWriteRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataMetaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jobsPartialUpdateDataMeta(id, patchedDataMetaWriteRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Method creates a new task in a database without any attached images and videos
         * @param {TaskWriteRequest} taskWriteRequest 
         * @param {string} [xOrganization] Organization unique slug
         * @param {string} [org] Organization unique slug
         * @param {number} [orgId] Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksCreate(taskWriteRequest: TaskWriteRequest, xOrganization?: string, org?: string, orgId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksCreate(taskWriteRequest, xOrganization, org, orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  The request POST /api/tasks/id/annotations will initiate file upload and will create the rq job on the server in which the process of annotations uploading from file will be carried out. Please, use the PUT /api/tasks/id/annotations endpoint for checking status of the process. 
         * @summary Method allows to initialize the  process of upload task annotations from a local or a cloud storage file
         * @param {number} id A unique integer value identifying this task.
         * @param {number} [cloudStorageId] Storage id
         * @param {string} [filename] Annotation file name
         * @param {string} [format] Input format name You can get the list of supported formats at: /server/annotation/formats
         * @param {TasksCreateAnnotationsLocationEnum} [location] where to import the annotation from
         * @param {boolean} [useDefaultLocation] Use the location that was configured in task to import annotations
         * @param {TaskAnnotationsWriteRequest | null} [taskAnnotationsWriteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksCreateAnnotations(id: number, cloudStorageId?: number, filename?: string, format?: string, location?: TasksCreateAnnotationsLocationEnum, useDefaultLocation?: boolean, taskAnnotationsWriteRequest?: TaskAnnotationsWriteRequest | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksCreateAnnotations(id, cloudStorageId, filename, format, location, useDefaultLocation, taskAnnotationsWriteRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  The backup import process is as follows:  The first request POST /api/tasks/backup will initiate file upload and will create the rq job on the server in which the process of a task creating from an uploaded backup will be carried out.  After initiating the backup upload, you will receive an rq_id parameter. Make sure to include this parameter as a query parameter in your subsequent requests to track the status of the task creation. Once the task has been successfully created, the server will return the id of the newly created task. 
         * @summary Method recreates a task from an attached task backup file
         * @param {string} [xOrganization] Organization unique slug
         * @param {number} [cloudStorageId] Storage id
         * @param {string} [filename] Backup file name
         * @param {TasksCreateBackupLocationEnum} [location] Where to import the backup file from
         * @param {string} [org] Organization unique slug
         * @param {number} [orgId] Organization identifier
         * @param {string} [rqId] rq id
         * @param {TaskFileRequest} [taskFileRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksCreateBackup(xOrganization?: string, cloudStorageId?: number, filename?: string, location?: TasksCreateBackupLocationEnum, org?: string, orgId?: number, rqId?: string, taskFileRequest?: TaskFileRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksCreateBackup(xOrganization, cloudStorageId, filename, location, org, orgId, rqId, taskFileRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Allows to upload data to a task. Supports the TUS open file uploading protocol (https://tus.io/).  Supports the following protocols:  1. A single Data request  and  2.1. An Upload-Start request 2.2.a. Regular TUS protocol requests (Upload-Length + Chunks) 2.2.b. Upload-Multiple requests 2.3. An Upload-Finish request  Requests: - Data - POST, no extra headers or \'Upload-Start\' + \'Upload-Finish\' headers.   Contains data in the body. - Upload-Start - POST, has an \'Upload-Start\' header. No body is expected. - Upload-Length - POST, has an \'Upload-Length\' header (see the TUS specification) - Chunk - HEAD/PATCH (see the TUS specification). Sent to /data/<file id> endpoints. - Upload-Finish - POST, has an \'Upload-Finish\' header. Can contain data in the body. - Upload-Multiple - POST, has an \'Upload-Multiple\' header. Contains data in the body.  The \'Upload-Finish\' request allows to specify the uploaded files should be ordered. This may be needed if the files can be sent unordered. To state that the input files are sent ordered, pass an empty list of files in the \'upload_file_order\' field. If the files are sent unordered, the ordered file list is expected in the \'upload_file_order\' field. It must be a list of string file paths, relative to the dataset root.  Example: files = [     \"cats/cat_1.jpg\",     \"dogs/dog2.jpg\",     \"image_3.png\",     ... ]  Independently of the file declaration field used (\'client_files\', \'server_files\', etc.), when the \'predefined\' sorting method is selected, the uploaded files will be ordered according to the \'.jsonl\' manifest file, if it is found in the list of files. For archives (e.g. \'.zip\'), a manifest file (\'*.jsonl\') is required when using the \'predefined\' file ordering. Such file must be provided next to the archive in the list of files. Read more about manifest files here: https://opencv.github.io/cvat/docs/manual/advanced/dataset_manifest/  After all data is sent, the operation status can be retrieved via the /status endpoint. 
         * @summary Method permanently attaches data (images, video, etc.) to a task
         * @param {number} id A unique integer value identifying this task.
         * @param {boolean} [uploadFinish] Finishes data upload. Can be combined with Upload-Start header to create task data with one request
         * @param {boolean} [uploadMultiple] Indicates that data with this request are single or multiple files that should be attached to a task
         * @param {boolean} [uploadStart] Initializes data upload. Optionally, can include upload metadata in the request body.
         * @param {DataRequest} [dataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksCreateData(id: number, uploadFinish?: boolean, uploadMultiple?: boolean, uploadStart?: boolean, dataRequest?: DataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksCreateData(id, uploadFinish, uploadMultiple, uploadStart, dataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Method deletes a specific task, all attached jobs, annotations, and data
         * @param {number} id A unique integer value identifying this task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Method deletes all annotations for a specific task
         * @param {number} id A unique integer value identifying this task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksDestroyAnnotations(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksDestroyAnnotations(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a paginated list of tasks
         * @param {string} [xOrganization] Organization unique slug
         * @param {string} [assignee] A simple equality filter for the assignee field
         * @param {TasksListDimensionEnum} [dimension] A simple equality filter for the dimension field
         * @param {string} [filter] A filter term. Available filter_fields: [\&#39;project_name\&#39;, \&#39;name\&#39;, \&#39;owner\&#39;, \&#39;status\&#39;, \&#39;assignee\&#39;, \&#39;subset\&#39;, \&#39;mode\&#39;, \&#39;dimension\&#39;, \&#39;tracker_link\&#39;, \&#39;id\&#39;, \&#39;project_id\&#39;, \&#39;updated_date\&#39;]
         * @param {string} [mode] A simple equality filter for the mode field
         * @param {string} [name] A simple equality filter for the name field
         * @param {string} [org] Organization unique slug
         * @param {number} [orgId] Organization identifier
         * @param {string} [owner] A simple equality filter for the owner field
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [projectId] A simple equality filter for the project_id field
         * @param {string} [projectName] A simple equality filter for the project_name field
         * @param {string} [search] A search term. Available search_fields: (\&#39;project_name\&#39;, \&#39;name\&#39;, \&#39;owner\&#39;, \&#39;status\&#39;, \&#39;assignee\&#39;, \&#39;subset\&#39;, \&#39;mode\&#39;, \&#39;dimension\&#39;, \&#39;tracker_link\&#39;)
         * @param {string} [sort] Which field to use when ordering the results. Available ordering_fields: [\&#39;project_name\&#39;, \&#39;name\&#39;, \&#39;owner\&#39;, \&#39;status\&#39;, \&#39;assignee\&#39;, \&#39;subset\&#39;, \&#39;mode\&#39;, \&#39;dimension\&#39;, \&#39;tracker_link\&#39;, \&#39;id\&#39;, \&#39;project_id\&#39;, \&#39;updated_date\&#39;]
         * @param {TasksListStatusEnum} [status] A simple equality filter for the status field
         * @param {string} [subset] A simple equality filter for the subset field
         * @param {string} [trackerLink] A simple equality filter for the tracker_link field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksList(xOrganization?: string, assignee?: string, dimension?: TasksListDimensionEnum, filter?: string, mode?: string, name?: string, org?: string, orgId?: number, owner?: string, page?: number, pageSize?: number, projectId?: number, projectName?: string, search?: string, sort?: string, status?: TasksListStatusEnum, subset?: string, trackerLink?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedTaskReadList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksList(xOrganization, assignee, dimension, filter, mode, name, org, orgId, owner, page, pageSize, projectId, projectName, search, sort, status, subset, trackerLink, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Methods does a partial update of chosen fields in a task
         * @param {number} id A unique integer value identifying this task.
         * @param {PatchedTaskWriteRequest} [patchedTaskWriteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksPartialUpdate(id: number, patchedTaskWriteRequest?: PatchedTaskWriteRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksPartialUpdate(id, patchedTaskWriteRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Method performs a partial update of annotations in a specific task
         * @param {TasksPartialUpdateAnnotationsActionEnum} action 
         * @param {number} id A unique integer value identifying this task.
         * @param {PatchedLabeledDataRequest} [patchedLabeledDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksPartialUpdateAnnotations(action: TasksPartialUpdateAnnotationsActionEnum, id: number, patchedLabeledDataRequest?: PatchedLabeledDataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabeledData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksPartialUpdateAnnotations(action, id, patchedLabeledDataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Method provides a meta information about media files which are related with the task
         * @param {number} id A unique integer value identifying this task.
         * @param {PatchedDataMetaWriteRequest} [patchedDataMetaWriteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksPartialUpdateDataMeta(id: number, patchedDataMetaWriteRequest?: PatchedDataMetaWriteRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataMetaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksPartialUpdateDataMeta(id, patchedDataMetaWriteRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Method returns details of a specific task
         * @param {number} id A unique integer value identifying this task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Method allows to download task annotations
         * @param {number} id A unique integer value identifying this task.
         * @param {TasksRetrieveAnnotationsActionEnum} [action] Used to start downloading process after annotation file had been created
         * @param {number} [cloudStorageId] Storage id
         * @param {string} [filename] Desired output file name
         * @param {string} [format] Desired output format name You can get the list of supported formats at: /server/annotation/formats
         * @param {TasksRetrieveAnnotationsLocationEnum} [location] Where need to save downloaded dataset
         * @param {boolean} [useDefaultLocation] Use the location that was configured in the task to export annotation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksRetrieveAnnotations(id: number, action?: TasksRetrieveAnnotationsActionEnum, cloudStorageId?: number, filename?: string, format?: string, location?: TasksRetrieveAnnotationsLocationEnum, useDefaultLocation?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnotationsRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksRetrieveAnnotations(id, action, cloudStorageId, filename, format, location, useDefaultLocation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Method backup a specified task
         * @param {number} id A unique integer value identifying this task.
         * @param {TasksRetrieveBackupActionEnum} [action] Used to start downloading process after backup file had been created
         * @param {number} [cloudStorageId] Storage id
         * @param {string} [filename] Backup file name
         * @param {TasksRetrieveBackupLocationEnum} [location] Where need to save downloaded backup
         * @param {boolean} [useDefaultLocation] Use the location that was configured in the task to export backup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksRetrieveBackup(id: number, action?: TasksRetrieveBackupActionEnum, cloudStorageId?: number, filename?: string, location?: TasksRetrieveBackupLocationEnum, useDefaultLocation?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksRetrieveBackup(id, action, cloudStorageId, filename, location, useDefaultLocation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Method returns data for a specific task
         * @param {number} id A unique integer value identifying this task.
         * @param {number} [number] A unique number value identifying chunk or frame
         * @param {TasksRetrieveDataQualityEnum} [quality] Specifies the quality level of the requested data
         * @param {TasksRetrieveDataTypeEnum} [type] Specifies the type of the requested data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksRetrieveData(id: number, number?: number, quality?: TasksRetrieveDataQualityEnum, type?: TasksRetrieveDataTypeEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksRetrieveData(id, number, quality, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Method provides a meta information about media files which are related with the task
         * @param {number} id A unique integer value identifying this task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksRetrieveDataMeta(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataMetaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksRetrieveDataMeta(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Export task as a dataset in a specific format
         * @param {string} format Desired output format name You can get the list of supported formats at: /server/annotation/formats
         * @param {number} id A unique integer value identifying this task.
         * @param {TasksRetrieveDatasetActionEnum} [action] Used to start downloading process after annotation file had been created
         * @param {number} [cloudStorageId] Storage id
         * @param {string} [filename] Desired output file name
         * @param {TasksRetrieveDatasetLocationEnum} [location] Where need to save downloaded dataset
         * @param {boolean} [useDefaultLocation] Use the location that was configured in task to export annotations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksRetrieveDataset(format: string, id: number, action?: TasksRetrieveDatasetActionEnum, cloudStorageId?: number, filename?: string, location?: TasksRetrieveDatasetLocationEnum, useDefaultLocation?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksRetrieveDataset(format, id, action, cloudStorageId, filename, location, useDefaultLocation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Method returns a preview image for the task
         * @param {number} id A unique integer value identifying this task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksRetrievePreview(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksRetrievePreview(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary When task is being created the method returns information about a status of the creation process
         * @param {number} id A unique integer value identifying this task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksRetrieveStatus(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RqStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksRetrieveStatus(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  To check the status of the process of uploading a task annotations from a file:  After initiating the annotations upload, you will receive an rq_id parameter. Make sure to include this parameter as a query parameter in your subsequent PUT /api/tasks/id/annotations requests to track the status of the annotations upload. 
         * @summary Method allows to upload task annotations or edit existing annotations
         * @param {number} id A unique integer value identifying this task.
         * @param {string} [format] Input format name You can get the list of supported formats at: /server/annotation/formats
         * @param {string} [rqId] rq id
         * @param {TaskAnnotationsUpdateRequest | null} [taskAnnotationsUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksUpdateAnnotations(id: number, format?: string, rqId?: string, taskAnnotationsUpdateRequest?: TaskAnnotationsUpdateRequest | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksUpdateAnnotations(id, format, rqId, taskAnnotationsUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TasksApi - factory interface
 * @export
 */
export const TasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TasksApiFp(configuration)
    return {
        /**
         * 
         * @summary Method provides a meta information about media files which are related with the job
         * @param {TasksApiJobsPartialUpdateDataMetaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsPartialUpdateDataMeta(requestParameters: TasksApiJobsPartialUpdateDataMetaRequest, options?: AxiosRequestConfig): AxiosPromise<DataMetaRead> {
            return localVarFp.jobsPartialUpdateDataMeta(requestParameters.id, requestParameters.patchedDataMetaWriteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Method creates a new task in a database without any attached images and videos
         * @param {TasksApiTasksCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksCreate(requestParameters: TasksApiTasksCreateRequest, options?: AxiosRequestConfig): AxiosPromise<TaskRead> {
            return localVarFp.tasksCreate(requestParameters.taskWriteRequest, requestParameters.xOrganization, requestParameters.org, requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         *  The request POST /api/tasks/id/annotations will initiate file upload and will create the rq job on the server in which the process of annotations uploading from file will be carried out. Please, use the PUT /api/tasks/id/annotations endpoint for checking status of the process. 
         * @summary Method allows to initialize the  process of upload task annotations from a local or a cloud storage file
         * @param {TasksApiTasksCreateAnnotationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksCreateAnnotations(requestParameters: TasksApiTasksCreateAnnotationsRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.tasksCreateAnnotations(requestParameters.id, requestParameters.cloudStorageId, requestParameters.filename, requestParameters.format, requestParameters.location, requestParameters.useDefaultLocation, requestParameters.taskAnnotationsWriteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *  The backup import process is as follows:  The first request POST /api/tasks/backup will initiate file upload and will create the rq job on the server in which the process of a task creating from an uploaded backup will be carried out.  After initiating the backup upload, you will receive an rq_id parameter. Make sure to include this parameter as a query parameter in your subsequent requests to track the status of the task creation. Once the task has been successfully created, the server will return the id of the newly created task. 
         * @summary Method recreates a task from an attached task backup file
         * @param {TasksApiTasksCreateBackupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksCreateBackup(requestParameters: TasksApiTasksCreateBackupRequest = {}, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.tasksCreateBackup(requestParameters.xOrganization, requestParameters.cloudStorageId, requestParameters.filename, requestParameters.location, requestParameters.org, requestParameters.orgId, requestParameters.rqId, requestParameters.taskFileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows to upload data to a task. Supports the TUS open file uploading protocol (https://tus.io/).  Supports the following protocols:  1. A single Data request  and  2.1. An Upload-Start request 2.2.a. Regular TUS protocol requests (Upload-Length + Chunks) 2.2.b. Upload-Multiple requests 2.3. An Upload-Finish request  Requests: - Data - POST, no extra headers or \'Upload-Start\' + \'Upload-Finish\' headers.   Contains data in the body. - Upload-Start - POST, has an \'Upload-Start\' header. No body is expected. - Upload-Length - POST, has an \'Upload-Length\' header (see the TUS specification) - Chunk - HEAD/PATCH (see the TUS specification). Sent to /data/<file id> endpoints. - Upload-Finish - POST, has an \'Upload-Finish\' header. Can contain data in the body. - Upload-Multiple - POST, has an \'Upload-Multiple\' header. Contains data in the body.  The \'Upload-Finish\' request allows to specify the uploaded files should be ordered. This may be needed if the files can be sent unordered. To state that the input files are sent ordered, pass an empty list of files in the \'upload_file_order\' field. If the files are sent unordered, the ordered file list is expected in the \'upload_file_order\' field. It must be a list of string file paths, relative to the dataset root.  Example: files = [     \"cats/cat_1.jpg\",     \"dogs/dog2.jpg\",     \"image_3.png\",     ... ]  Independently of the file declaration field used (\'client_files\', \'server_files\', etc.), when the \'predefined\' sorting method is selected, the uploaded files will be ordered according to the \'.jsonl\' manifest file, if it is found in the list of files. For archives (e.g. \'.zip\'), a manifest file (\'*.jsonl\') is required when using the \'predefined\' file ordering. Such file must be provided next to the archive in the list of files. Read more about manifest files here: https://opencv.github.io/cvat/docs/manual/advanced/dataset_manifest/  After all data is sent, the operation status can be retrieved via the /status endpoint. 
         * @summary Method permanently attaches data (images, video, etc.) to a task
         * @param {TasksApiTasksCreateDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksCreateData(requestParameters: TasksApiTasksCreateDataRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.tasksCreateData(requestParameters.id, requestParameters.uploadFinish, requestParameters.uploadMultiple, requestParameters.uploadStart, requestParameters.dataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Method deletes a specific task, all attached jobs, annotations, and data
         * @param {TasksApiTasksDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksDestroy(requestParameters: TasksApiTasksDestroyRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.tasksDestroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Method deletes all annotations for a specific task
         * @param {TasksApiTasksDestroyAnnotationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksDestroyAnnotations(requestParameters: TasksApiTasksDestroyAnnotationsRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.tasksDestroyAnnotations(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a paginated list of tasks
         * @param {TasksApiTasksListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksList(requestParameters: TasksApiTasksListRequest = {}, options?: AxiosRequestConfig): AxiosPromise<PaginatedTaskReadList> {
            return localVarFp.tasksList(requestParameters.xOrganization, requestParameters.assignee, requestParameters.dimension, requestParameters.filter, requestParameters.mode, requestParameters.name, requestParameters.org, requestParameters.orgId, requestParameters.owner, requestParameters.page, requestParameters.pageSize, requestParameters.projectId, requestParameters.projectName, requestParameters.search, requestParameters.sort, requestParameters.status, requestParameters.subset, requestParameters.trackerLink, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Methods does a partial update of chosen fields in a task
         * @param {TasksApiTasksPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksPartialUpdate(requestParameters: TasksApiTasksPartialUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<TaskRead> {
            return localVarFp.tasksPartialUpdate(requestParameters.id, requestParameters.patchedTaskWriteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Method performs a partial update of annotations in a specific task
         * @param {TasksApiTasksPartialUpdateAnnotationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksPartialUpdateAnnotations(requestParameters: TasksApiTasksPartialUpdateAnnotationsRequest, options?: AxiosRequestConfig): AxiosPromise<LabeledData> {
            return localVarFp.tasksPartialUpdateAnnotations(requestParameters.action, requestParameters.id, requestParameters.patchedLabeledDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Method provides a meta information about media files which are related with the task
         * @param {TasksApiTasksPartialUpdateDataMetaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksPartialUpdateDataMeta(requestParameters: TasksApiTasksPartialUpdateDataMetaRequest, options?: AxiosRequestConfig): AxiosPromise<DataMetaRead> {
            return localVarFp.tasksPartialUpdateDataMeta(requestParameters.id, requestParameters.patchedDataMetaWriteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Method returns details of a specific task
         * @param {TasksApiTasksRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksRetrieve(requestParameters: TasksApiTasksRetrieveRequest, options?: AxiosRequestConfig): AxiosPromise<TaskRead> {
            return localVarFp.tasksRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Method allows to download task annotations
         * @param {TasksApiTasksRetrieveAnnotationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksRetrieveAnnotations(requestParameters: TasksApiTasksRetrieveAnnotationsRequest, options?: AxiosRequestConfig): AxiosPromise<AnnotationsRead> {
            return localVarFp.tasksRetrieveAnnotations(requestParameters.id, requestParameters.action, requestParameters.cloudStorageId, requestParameters.filename, requestParameters.format, requestParameters.location, requestParameters.useDefaultLocation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Method backup a specified task
         * @param {TasksApiTasksRetrieveBackupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksRetrieveBackup(requestParameters: TasksApiTasksRetrieveBackupRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.tasksRetrieveBackup(requestParameters.id, requestParameters.action, requestParameters.cloudStorageId, requestParameters.filename, requestParameters.location, requestParameters.useDefaultLocation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Method returns data for a specific task
         * @param {TasksApiTasksRetrieveDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksRetrieveData(requestParameters: TasksApiTasksRetrieveDataRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.tasksRetrieveData(requestParameters.id, requestParameters.number, requestParameters.quality, requestParameters.type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Method provides a meta information about media files which are related with the task
         * @param {TasksApiTasksRetrieveDataMetaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksRetrieveDataMeta(requestParameters: TasksApiTasksRetrieveDataMetaRequest, options?: AxiosRequestConfig): AxiosPromise<DataMetaRead> {
            return localVarFp.tasksRetrieveDataMeta(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Export task as a dataset in a specific format
         * @param {TasksApiTasksRetrieveDatasetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksRetrieveDataset(requestParameters: TasksApiTasksRetrieveDatasetRequest, options?: AxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.tasksRetrieveDataset(requestParameters.format, requestParameters.id, requestParameters.action, requestParameters.cloudStorageId, requestParameters.filename, requestParameters.location, requestParameters.useDefaultLocation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Method returns a preview image for the task
         * @param {TasksApiTasksRetrievePreviewRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksRetrievePreview(requestParameters: TasksApiTasksRetrievePreviewRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.tasksRetrievePreview(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary When task is being created the method returns information about a status of the creation process
         * @param {TasksApiTasksRetrieveStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksRetrieveStatus(requestParameters: TasksApiTasksRetrieveStatusRequest, options?: AxiosRequestConfig): AxiosPromise<RqStatus> {
            return localVarFp.tasksRetrieveStatus(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *  To check the status of the process of uploading a task annotations from a file:  After initiating the annotations upload, you will receive an rq_id parameter. Make sure to include this parameter as a query parameter in your subsequent PUT /api/tasks/id/annotations requests to track the status of the annotations upload. 
         * @summary Method allows to upload task annotations or edit existing annotations
         * @param {TasksApiTasksUpdateAnnotationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksUpdateAnnotations(requestParameters: TasksApiTasksUpdateAnnotationsRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.tasksUpdateAnnotations(requestParameters.id, requestParameters.format, requestParameters.rqId, requestParameters.taskAnnotationsUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for jobsPartialUpdateDataMeta operation in TasksApi.
 * @export
 * @interface TasksApiJobsPartialUpdateDataMetaRequest
 */
export interface TasksApiJobsPartialUpdateDataMetaRequest {
    /**
     * A unique integer value identifying this job.
     * @type {number}
     * @memberof TasksApiJobsPartialUpdateDataMeta
     */
    readonly id: number

    /**
     * 
     * @type {PatchedDataMetaWriteRequest}
     * @memberof TasksApiJobsPartialUpdateDataMeta
     */
    readonly patchedDataMetaWriteRequest?: PatchedDataMetaWriteRequest
}

/**
 * Request parameters for tasksCreate operation in TasksApi.
 * @export
 * @interface TasksApiTasksCreateRequest
 */
export interface TasksApiTasksCreateRequest {
    /**
     * 
     * @type {TaskWriteRequest}
     * @memberof TasksApiTasksCreate
     */
    readonly taskWriteRequest: TaskWriteRequest

    /**
     * Organization unique slug
     * @type {string}
     * @memberof TasksApiTasksCreate
     */
    readonly xOrganization?: string

    /**
     * Organization unique slug
     * @type {string}
     * @memberof TasksApiTasksCreate
     */
    readonly org?: string

    /**
     * Organization identifier
     * @type {number}
     * @memberof TasksApiTasksCreate
     */
    readonly orgId?: number
}

/**
 * Request parameters for tasksCreateAnnotations operation in TasksApi.
 * @export
 * @interface TasksApiTasksCreateAnnotationsRequest
 */
export interface TasksApiTasksCreateAnnotationsRequest {
    /**
     * A unique integer value identifying this task.
     * @type {number}
     * @memberof TasksApiTasksCreateAnnotations
     */
    readonly id: number

    /**
     * Storage id
     * @type {number}
     * @memberof TasksApiTasksCreateAnnotations
     */
    readonly cloudStorageId?: number

    /**
     * Annotation file name
     * @type {string}
     * @memberof TasksApiTasksCreateAnnotations
     */
    readonly filename?: string

    /**
     * Input format name You can get the list of supported formats at: /server/annotation/formats
     * @type {string}
     * @memberof TasksApiTasksCreateAnnotations
     */
    readonly format?: string

    /**
     * where to import the annotation from
     * @type {'cloud_storage' | 'local'}
     * @memberof TasksApiTasksCreateAnnotations
     */
    readonly location?: TasksCreateAnnotationsLocationEnum

    /**
     * Use the location that was configured in task to import annotations
     * @type {boolean}
     * @memberof TasksApiTasksCreateAnnotations
     */
    readonly useDefaultLocation?: boolean

    /**
     * 
     * @type {TaskAnnotationsWriteRequest}
     * @memberof TasksApiTasksCreateAnnotations
     */
    readonly taskAnnotationsWriteRequest?: TaskAnnotationsWriteRequest | null
}

/**
 * Request parameters for tasksCreateBackup operation in TasksApi.
 * @export
 * @interface TasksApiTasksCreateBackupRequest
 */
export interface TasksApiTasksCreateBackupRequest {
    /**
     * Organization unique slug
     * @type {string}
     * @memberof TasksApiTasksCreateBackup
     */
    readonly xOrganization?: string

    /**
     * Storage id
     * @type {number}
     * @memberof TasksApiTasksCreateBackup
     */
    readonly cloudStorageId?: number

    /**
     * Backup file name
     * @type {string}
     * @memberof TasksApiTasksCreateBackup
     */
    readonly filename?: string

    /**
     * Where to import the backup file from
     * @type {'cloud_storage' | 'local'}
     * @memberof TasksApiTasksCreateBackup
     */
    readonly location?: TasksCreateBackupLocationEnum

    /**
     * Organization unique slug
     * @type {string}
     * @memberof TasksApiTasksCreateBackup
     */
    readonly org?: string

    /**
     * Organization identifier
     * @type {number}
     * @memberof TasksApiTasksCreateBackup
     */
    readonly orgId?: number

    /**
     * rq id
     * @type {string}
     * @memberof TasksApiTasksCreateBackup
     */
    readonly rqId?: string

    /**
     * 
     * @type {TaskFileRequest}
     * @memberof TasksApiTasksCreateBackup
     */
    readonly taskFileRequest?: TaskFileRequest
}

/**
 * Request parameters for tasksCreateData operation in TasksApi.
 * @export
 * @interface TasksApiTasksCreateDataRequest
 */
export interface TasksApiTasksCreateDataRequest {
    /**
     * A unique integer value identifying this task.
     * @type {number}
     * @memberof TasksApiTasksCreateData
     */
    readonly id: number

    /**
     * Finishes data upload. Can be combined with Upload-Start header to create task data with one request
     * @type {boolean}
     * @memberof TasksApiTasksCreateData
     */
    readonly uploadFinish?: boolean

    /**
     * Indicates that data with this request are single or multiple files that should be attached to a task
     * @type {boolean}
     * @memberof TasksApiTasksCreateData
     */
    readonly uploadMultiple?: boolean

    /**
     * Initializes data upload. Optionally, can include upload metadata in the request body.
     * @type {boolean}
     * @memberof TasksApiTasksCreateData
     */
    readonly uploadStart?: boolean

    /**
     * 
     * @type {DataRequest}
     * @memberof TasksApiTasksCreateData
     */
    readonly dataRequest?: DataRequest
}

/**
 * Request parameters for tasksDestroy operation in TasksApi.
 * @export
 * @interface TasksApiTasksDestroyRequest
 */
export interface TasksApiTasksDestroyRequest {
    /**
     * A unique integer value identifying this task.
     * @type {number}
     * @memberof TasksApiTasksDestroy
     */
    readonly id: number
}

/**
 * Request parameters for tasksDestroyAnnotations operation in TasksApi.
 * @export
 * @interface TasksApiTasksDestroyAnnotationsRequest
 */
export interface TasksApiTasksDestroyAnnotationsRequest {
    /**
     * A unique integer value identifying this task.
     * @type {number}
     * @memberof TasksApiTasksDestroyAnnotations
     */
    readonly id: number
}

/**
 * Request parameters for tasksList operation in TasksApi.
 * @export
 * @interface TasksApiTasksListRequest
 */
export interface TasksApiTasksListRequest {
    /**
     * Organization unique slug
     * @type {string}
     * @memberof TasksApiTasksList
     */
    readonly xOrganization?: string

    /**
     * A simple equality filter for the assignee field
     * @type {string}
     * @memberof TasksApiTasksList
     */
    readonly assignee?: string

    /**
     * A simple equality filter for the dimension field
     * @type {'3d' | '2d'}
     * @memberof TasksApiTasksList
     */
    readonly dimension?: TasksListDimensionEnum

    /**
     * A filter term. Available filter_fields: [\&#39;project_name\&#39;, \&#39;name\&#39;, \&#39;owner\&#39;, \&#39;status\&#39;, \&#39;assignee\&#39;, \&#39;subset\&#39;, \&#39;mode\&#39;, \&#39;dimension\&#39;, \&#39;tracker_link\&#39;, \&#39;id\&#39;, \&#39;project_id\&#39;, \&#39;updated_date\&#39;]
     * @type {string}
     * @memberof TasksApiTasksList
     */
    readonly filter?: string

    /**
     * A simple equality filter for the mode field
     * @type {string}
     * @memberof TasksApiTasksList
     */
    readonly mode?: string

    /**
     * A simple equality filter for the name field
     * @type {string}
     * @memberof TasksApiTasksList
     */
    readonly name?: string

    /**
     * Organization unique slug
     * @type {string}
     * @memberof TasksApiTasksList
     */
    readonly org?: string

    /**
     * Organization identifier
     * @type {number}
     * @memberof TasksApiTasksList
     */
    readonly orgId?: number

    /**
     * A simple equality filter for the owner field
     * @type {string}
     * @memberof TasksApiTasksList
     */
    readonly owner?: string

    /**
     * A page number within the paginated result set.
     * @type {number}
     * @memberof TasksApiTasksList
     */
    readonly page?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof TasksApiTasksList
     */
    readonly pageSize?: number

    /**
     * A simple equality filter for the project_id field
     * @type {number}
     * @memberof TasksApiTasksList
     */
    readonly projectId?: number

    /**
     * A simple equality filter for the project_name field
     * @type {string}
     * @memberof TasksApiTasksList
     */
    readonly projectName?: string

    /**
     * A search term. Available search_fields: (\&#39;project_name\&#39;, \&#39;name\&#39;, \&#39;owner\&#39;, \&#39;status\&#39;, \&#39;assignee\&#39;, \&#39;subset\&#39;, \&#39;mode\&#39;, \&#39;dimension\&#39;, \&#39;tracker_link\&#39;)
     * @type {string}
     * @memberof TasksApiTasksList
     */
    readonly search?: string

    /**
     * Which field to use when ordering the results. Available ordering_fields: [\&#39;project_name\&#39;, \&#39;name\&#39;, \&#39;owner\&#39;, \&#39;status\&#39;, \&#39;assignee\&#39;, \&#39;subset\&#39;, \&#39;mode\&#39;, \&#39;dimension\&#39;, \&#39;tracker_link\&#39;, \&#39;id\&#39;, \&#39;project_id\&#39;, \&#39;updated_date\&#39;]
     * @type {string}
     * @memberof TasksApiTasksList
     */
    readonly sort?: string

    /**
     * A simple equality filter for the status field
     * @type {'annotation' | 'validation' | 'completed'}
     * @memberof TasksApiTasksList
     */
    readonly status?: TasksListStatusEnum

    /**
     * A simple equality filter for the subset field
     * @type {string}
     * @memberof TasksApiTasksList
     */
    readonly subset?: string

    /**
     * A simple equality filter for the tracker_link field
     * @type {string}
     * @memberof TasksApiTasksList
     */
    readonly trackerLink?: string
}

/**
 * Request parameters for tasksPartialUpdate operation in TasksApi.
 * @export
 * @interface TasksApiTasksPartialUpdateRequest
 */
export interface TasksApiTasksPartialUpdateRequest {
    /**
     * A unique integer value identifying this task.
     * @type {number}
     * @memberof TasksApiTasksPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {PatchedTaskWriteRequest}
     * @memberof TasksApiTasksPartialUpdate
     */
    readonly patchedTaskWriteRequest?: PatchedTaskWriteRequest
}

/**
 * Request parameters for tasksPartialUpdateAnnotations operation in TasksApi.
 * @export
 * @interface TasksApiTasksPartialUpdateAnnotationsRequest
 */
export interface TasksApiTasksPartialUpdateAnnotationsRequest {
    /**
     * 
     * @type {'create' | 'delete' | 'update'}
     * @memberof TasksApiTasksPartialUpdateAnnotations
     */
    readonly action: TasksPartialUpdateAnnotationsActionEnum

    /**
     * A unique integer value identifying this task.
     * @type {number}
     * @memberof TasksApiTasksPartialUpdateAnnotations
     */
    readonly id: number

    /**
     * 
     * @type {PatchedLabeledDataRequest}
     * @memberof TasksApiTasksPartialUpdateAnnotations
     */
    readonly patchedLabeledDataRequest?: PatchedLabeledDataRequest
}

/**
 * Request parameters for tasksPartialUpdateDataMeta operation in TasksApi.
 * @export
 * @interface TasksApiTasksPartialUpdateDataMetaRequest
 */
export interface TasksApiTasksPartialUpdateDataMetaRequest {
    /**
     * A unique integer value identifying this task.
     * @type {number}
     * @memberof TasksApiTasksPartialUpdateDataMeta
     */
    readonly id: number

    /**
     * 
     * @type {PatchedDataMetaWriteRequest}
     * @memberof TasksApiTasksPartialUpdateDataMeta
     */
    readonly patchedDataMetaWriteRequest?: PatchedDataMetaWriteRequest
}

/**
 * Request parameters for tasksRetrieve operation in TasksApi.
 * @export
 * @interface TasksApiTasksRetrieveRequest
 */
export interface TasksApiTasksRetrieveRequest {
    /**
     * A unique integer value identifying this task.
     * @type {number}
     * @memberof TasksApiTasksRetrieve
     */
    readonly id: number
}

/**
 * Request parameters for tasksRetrieveAnnotations operation in TasksApi.
 * @export
 * @interface TasksApiTasksRetrieveAnnotationsRequest
 */
export interface TasksApiTasksRetrieveAnnotationsRequest {
    /**
     * A unique integer value identifying this task.
     * @type {number}
     * @memberof TasksApiTasksRetrieveAnnotations
     */
    readonly id: number

    /**
     * Used to start downloading process after annotation file had been created
     * @type {'download'}
     * @memberof TasksApiTasksRetrieveAnnotations
     */
    readonly action?: TasksRetrieveAnnotationsActionEnum

    /**
     * Storage id
     * @type {number}
     * @memberof TasksApiTasksRetrieveAnnotations
     */
    readonly cloudStorageId?: number

    /**
     * Desired output file name
     * @type {string}
     * @memberof TasksApiTasksRetrieveAnnotations
     */
    readonly filename?: string

    /**
     * Desired output format name You can get the list of supported formats at: /server/annotation/formats
     * @type {string}
     * @memberof TasksApiTasksRetrieveAnnotations
     */
    readonly format?: string

    /**
     * Where need to save downloaded dataset
     * @type {'cloud_storage' | 'local'}
     * @memberof TasksApiTasksRetrieveAnnotations
     */
    readonly location?: TasksRetrieveAnnotationsLocationEnum

    /**
     * Use the location that was configured in the task to export annotation
     * @type {boolean}
     * @memberof TasksApiTasksRetrieveAnnotations
     */
    readonly useDefaultLocation?: boolean
}

/**
 * Request parameters for tasksRetrieveBackup operation in TasksApi.
 * @export
 * @interface TasksApiTasksRetrieveBackupRequest
 */
export interface TasksApiTasksRetrieveBackupRequest {
    /**
     * A unique integer value identifying this task.
     * @type {number}
     * @memberof TasksApiTasksRetrieveBackup
     */
    readonly id: number

    /**
     * Used to start downloading process after backup file had been created
     * @type {'download'}
     * @memberof TasksApiTasksRetrieveBackup
     */
    readonly action?: TasksRetrieveBackupActionEnum

    /**
     * Storage id
     * @type {number}
     * @memberof TasksApiTasksRetrieveBackup
     */
    readonly cloudStorageId?: number

    /**
     * Backup file name
     * @type {string}
     * @memberof TasksApiTasksRetrieveBackup
     */
    readonly filename?: string

    /**
     * Where need to save downloaded backup
     * @type {'cloud_storage' | 'local'}
     * @memberof TasksApiTasksRetrieveBackup
     */
    readonly location?: TasksRetrieveBackupLocationEnum

    /**
     * Use the location that was configured in the task to export backup
     * @type {boolean}
     * @memberof TasksApiTasksRetrieveBackup
     */
    readonly useDefaultLocation?: boolean
}

/**
 * Request parameters for tasksRetrieveData operation in TasksApi.
 * @export
 * @interface TasksApiTasksRetrieveDataRequest
 */
export interface TasksApiTasksRetrieveDataRequest {
    /**
     * A unique integer value identifying this task.
     * @type {number}
     * @memberof TasksApiTasksRetrieveData
     */
    readonly id: number

    /**
     * A unique number value identifying chunk or frame
     * @type {number}
     * @memberof TasksApiTasksRetrieveData
     */
    readonly number?: number

    /**
     * Specifies the quality level of the requested data
     * @type {'compressed' | 'original'}
     * @memberof TasksApiTasksRetrieveData
     */
    readonly quality?: TasksRetrieveDataQualityEnum

    /**
     * Specifies the type of the requested data
     * @type {'chunk' | 'context_image' | 'frame'}
     * @memberof TasksApiTasksRetrieveData
     */
    readonly type?: TasksRetrieveDataTypeEnum
}

/**
 * Request parameters for tasksRetrieveDataMeta operation in TasksApi.
 * @export
 * @interface TasksApiTasksRetrieveDataMetaRequest
 */
export interface TasksApiTasksRetrieveDataMetaRequest {
    /**
     * A unique integer value identifying this task.
     * @type {number}
     * @memberof TasksApiTasksRetrieveDataMeta
     */
    readonly id: number
}

/**
 * Request parameters for tasksRetrieveDataset operation in TasksApi.
 * @export
 * @interface TasksApiTasksRetrieveDatasetRequest
 */
export interface TasksApiTasksRetrieveDatasetRequest {
    /**
     * Desired output format name You can get the list of supported formats at: /server/annotation/formats
     * @type {string}
     * @memberof TasksApiTasksRetrieveDataset
     */
    readonly format: string

    /**
     * A unique integer value identifying this task.
     * @type {number}
     * @memberof TasksApiTasksRetrieveDataset
     */
    readonly id: number

    /**
     * Used to start downloading process after annotation file had been created
     * @type {'download'}
     * @memberof TasksApiTasksRetrieveDataset
     */
    readonly action?: TasksRetrieveDatasetActionEnum

    /**
     * Storage id
     * @type {number}
     * @memberof TasksApiTasksRetrieveDataset
     */
    readonly cloudStorageId?: number

    /**
     * Desired output file name
     * @type {string}
     * @memberof TasksApiTasksRetrieveDataset
     */
    readonly filename?: string

    /**
     * Where need to save downloaded dataset
     * @type {'cloud_storage' | 'local'}
     * @memberof TasksApiTasksRetrieveDataset
     */
    readonly location?: TasksRetrieveDatasetLocationEnum

    /**
     * Use the location that was configured in task to export annotations
     * @type {boolean}
     * @memberof TasksApiTasksRetrieveDataset
     */
    readonly useDefaultLocation?: boolean
}

/**
 * Request parameters for tasksRetrievePreview operation in TasksApi.
 * @export
 * @interface TasksApiTasksRetrievePreviewRequest
 */
export interface TasksApiTasksRetrievePreviewRequest {
    /**
     * A unique integer value identifying this task.
     * @type {number}
     * @memberof TasksApiTasksRetrievePreview
     */
    readonly id: number
}

/**
 * Request parameters for tasksRetrieveStatus operation in TasksApi.
 * @export
 * @interface TasksApiTasksRetrieveStatusRequest
 */
export interface TasksApiTasksRetrieveStatusRequest {
    /**
     * A unique integer value identifying this task.
     * @type {number}
     * @memberof TasksApiTasksRetrieveStatus
     */
    readonly id: number
}

/**
 * Request parameters for tasksUpdateAnnotations operation in TasksApi.
 * @export
 * @interface TasksApiTasksUpdateAnnotationsRequest
 */
export interface TasksApiTasksUpdateAnnotationsRequest {
    /**
     * A unique integer value identifying this task.
     * @type {number}
     * @memberof TasksApiTasksUpdateAnnotations
     */
    readonly id: number

    /**
     * Input format name You can get the list of supported formats at: /server/annotation/formats
     * @type {string}
     * @memberof TasksApiTasksUpdateAnnotations
     */
    readonly format?: string

    /**
     * rq id
     * @type {string}
     * @memberof TasksApiTasksUpdateAnnotations
     */
    readonly rqId?: string

    /**
     * 
     * @type {TaskAnnotationsUpdateRequest}
     * @memberof TasksApiTasksUpdateAnnotations
     */
    readonly taskAnnotationsUpdateRequest?: TaskAnnotationsUpdateRequest | null
}

/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
export class TasksApi extends BaseAPI {
    /**
     * 
     * @summary Method provides a meta information about media files which are related with the job
     * @param {TasksApiJobsPartialUpdateDataMetaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public jobsPartialUpdateDataMeta(requestParameters: TasksApiJobsPartialUpdateDataMetaRequest, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).jobsPartialUpdateDataMeta(requestParameters.id, requestParameters.patchedDataMetaWriteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Method creates a new task in a database without any attached images and videos
     * @param {TasksApiTasksCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksCreate(requestParameters: TasksApiTasksCreateRequest, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksCreate(requestParameters.taskWriteRequest, requestParameters.xOrganization, requestParameters.org, requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  The request POST /api/tasks/id/annotations will initiate file upload and will create the rq job on the server in which the process of annotations uploading from file will be carried out. Please, use the PUT /api/tasks/id/annotations endpoint for checking status of the process. 
     * @summary Method allows to initialize the  process of upload task annotations from a local or a cloud storage file
     * @param {TasksApiTasksCreateAnnotationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksCreateAnnotations(requestParameters: TasksApiTasksCreateAnnotationsRequest, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksCreateAnnotations(requestParameters.id, requestParameters.cloudStorageId, requestParameters.filename, requestParameters.format, requestParameters.location, requestParameters.useDefaultLocation, requestParameters.taskAnnotationsWriteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  The backup import process is as follows:  The first request POST /api/tasks/backup will initiate file upload and will create the rq job on the server in which the process of a task creating from an uploaded backup will be carried out.  After initiating the backup upload, you will receive an rq_id parameter. Make sure to include this parameter as a query parameter in your subsequent requests to track the status of the task creation. Once the task has been successfully created, the server will return the id of the newly created task. 
     * @summary Method recreates a task from an attached task backup file
     * @param {TasksApiTasksCreateBackupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksCreateBackup(requestParameters: TasksApiTasksCreateBackupRequest = {}, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksCreateBackup(requestParameters.xOrganization, requestParameters.cloudStorageId, requestParameters.filename, requestParameters.location, requestParameters.org, requestParameters.orgId, requestParameters.rqId, requestParameters.taskFileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows to upload data to a task. Supports the TUS open file uploading protocol (https://tus.io/).  Supports the following protocols:  1. A single Data request  and  2.1. An Upload-Start request 2.2.a. Regular TUS protocol requests (Upload-Length + Chunks) 2.2.b. Upload-Multiple requests 2.3. An Upload-Finish request  Requests: - Data - POST, no extra headers or \'Upload-Start\' + \'Upload-Finish\' headers.   Contains data in the body. - Upload-Start - POST, has an \'Upload-Start\' header. No body is expected. - Upload-Length - POST, has an \'Upload-Length\' header (see the TUS specification) - Chunk - HEAD/PATCH (see the TUS specification). Sent to /data/<file id> endpoints. - Upload-Finish - POST, has an \'Upload-Finish\' header. Can contain data in the body. - Upload-Multiple - POST, has an \'Upload-Multiple\' header. Contains data in the body.  The \'Upload-Finish\' request allows to specify the uploaded files should be ordered. This may be needed if the files can be sent unordered. To state that the input files are sent ordered, pass an empty list of files in the \'upload_file_order\' field. If the files are sent unordered, the ordered file list is expected in the \'upload_file_order\' field. It must be a list of string file paths, relative to the dataset root.  Example: files = [     \"cats/cat_1.jpg\",     \"dogs/dog2.jpg\",     \"image_3.png\",     ... ]  Independently of the file declaration field used (\'client_files\', \'server_files\', etc.), when the \'predefined\' sorting method is selected, the uploaded files will be ordered according to the \'.jsonl\' manifest file, if it is found in the list of files. For archives (e.g. \'.zip\'), a manifest file (\'*.jsonl\') is required when using the \'predefined\' file ordering. Such file must be provided next to the archive in the list of files. Read more about manifest files here: https://opencv.github.io/cvat/docs/manual/advanced/dataset_manifest/  After all data is sent, the operation status can be retrieved via the /status endpoint. 
     * @summary Method permanently attaches data (images, video, etc.) to a task
     * @param {TasksApiTasksCreateDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksCreateData(requestParameters: TasksApiTasksCreateDataRequest, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksCreateData(requestParameters.id, requestParameters.uploadFinish, requestParameters.uploadMultiple, requestParameters.uploadStart, requestParameters.dataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Method deletes a specific task, all attached jobs, annotations, and data
     * @param {TasksApiTasksDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksDestroy(requestParameters: TasksApiTasksDestroyRequest, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Method deletes all annotations for a specific task
     * @param {TasksApiTasksDestroyAnnotationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksDestroyAnnotations(requestParameters: TasksApiTasksDestroyAnnotationsRequest, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksDestroyAnnotations(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a paginated list of tasks
     * @param {TasksApiTasksListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksList(requestParameters: TasksApiTasksListRequest = {}, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksList(requestParameters.xOrganization, requestParameters.assignee, requestParameters.dimension, requestParameters.filter, requestParameters.mode, requestParameters.name, requestParameters.org, requestParameters.orgId, requestParameters.owner, requestParameters.page, requestParameters.pageSize, requestParameters.projectId, requestParameters.projectName, requestParameters.search, requestParameters.sort, requestParameters.status, requestParameters.subset, requestParameters.trackerLink, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Methods does a partial update of chosen fields in a task
     * @param {TasksApiTasksPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksPartialUpdate(requestParameters: TasksApiTasksPartialUpdateRequest, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksPartialUpdate(requestParameters.id, requestParameters.patchedTaskWriteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Method performs a partial update of annotations in a specific task
     * @param {TasksApiTasksPartialUpdateAnnotationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksPartialUpdateAnnotations(requestParameters: TasksApiTasksPartialUpdateAnnotationsRequest, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksPartialUpdateAnnotations(requestParameters.action, requestParameters.id, requestParameters.patchedLabeledDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Method provides a meta information about media files which are related with the task
     * @param {TasksApiTasksPartialUpdateDataMetaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksPartialUpdateDataMeta(requestParameters: TasksApiTasksPartialUpdateDataMetaRequest, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksPartialUpdateDataMeta(requestParameters.id, requestParameters.patchedDataMetaWriteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Method returns details of a specific task
     * @param {TasksApiTasksRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksRetrieve(requestParameters: TasksApiTasksRetrieveRequest, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Method allows to download task annotations
     * @param {TasksApiTasksRetrieveAnnotationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksRetrieveAnnotations(requestParameters: TasksApiTasksRetrieveAnnotationsRequest, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksRetrieveAnnotations(requestParameters.id, requestParameters.action, requestParameters.cloudStorageId, requestParameters.filename, requestParameters.format, requestParameters.location, requestParameters.useDefaultLocation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Method backup a specified task
     * @param {TasksApiTasksRetrieveBackupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksRetrieveBackup(requestParameters: TasksApiTasksRetrieveBackupRequest, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksRetrieveBackup(requestParameters.id, requestParameters.action, requestParameters.cloudStorageId, requestParameters.filename, requestParameters.location, requestParameters.useDefaultLocation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Method returns data for a specific task
     * @param {TasksApiTasksRetrieveDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksRetrieveData(requestParameters: TasksApiTasksRetrieveDataRequest, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksRetrieveData(requestParameters.id, requestParameters.number, requestParameters.quality, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Method provides a meta information about media files which are related with the task
     * @param {TasksApiTasksRetrieveDataMetaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksRetrieveDataMeta(requestParameters: TasksApiTasksRetrieveDataMetaRequest, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksRetrieveDataMeta(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Export task as a dataset in a specific format
     * @param {TasksApiTasksRetrieveDatasetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksRetrieveDataset(requestParameters: TasksApiTasksRetrieveDatasetRequest, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksRetrieveDataset(requestParameters.format, requestParameters.id, requestParameters.action, requestParameters.cloudStorageId, requestParameters.filename, requestParameters.location, requestParameters.useDefaultLocation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Method returns a preview image for the task
     * @param {TasksApiTasksRetrievePreviewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksRetrievePreview(requestParameters: TasksApiTasksRetrievePreviewRequest, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksRetrievePreview(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary When task is being created the method returns information about a status of the creation process
     * @param {TasksApiTasksRetrieveStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksRetrieveStatus(requestParameters: TasksApiTasksRetrieveStatusRequest, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksRetrieveStatus(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  To check the status of the process of uploading a task annotations from a file:  After initiating the annotations upload, you will receive an rq_id parameter. Make sure to include this parameter as a query parameter in your subsequent PUT /api/tasks/id/annotations requests to track the status of the annotations upload. 
     * @summary Method allows to upload task annotations or edit existing annotations
     * @param {TasksApiTasksUpdateAnnotationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksUpdateAnnotations(requestParameters: TasksApiTasksUpdateAnnotationsRequest, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksUpdateAnnotations(requestParameters.id, requestParameters.format, requestParameters.rqId, requestParameters.taskAnnotationsUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const TasksCreateAnnotationsLocationEnum = {
    CloudStorage: 'cloud_storage',
    Local: 'local'
} as const;
export type TasksCreateAnnotationsLocationEnum = typeof TasksCreateAnnotationsLocationEnum[keyof typeof TasksCreateAnnotationsLocationEnum];
/**
 * @export
 */
export const TasksCreateBackupLocationEnum = {
    CloudStorage: 'cloud_storage',
    Local: 'local'
} as const;
export type TasksCreateBackupLocationEnum = typeof TasksCreateBackupLocationEnum[keyof typeof TasksCreateBackupLocationEnum];
/**
 * @export
 */
export const TasksListDimensionEnum = {
    _3d: '3d',
    _2d: '2d'
} as const;
export type TasksListDimensionEnum = typeof TasksListDimensionEnum[keyof typeof TasksListDimensionEnum];
/**
 * @export
 */
export const TasksListStatusEnum = {
    Annotation: 'annotation',
    Validation: 'validation',
    Completed: 'completed'
} as const;
export type TasksListStatusEnum = typeof TasksListStatusEnum[keyof typeof TasksListStatusEnum];
/**
 * @export
 */
export const TasksPartialUpdateAnnotationsActionEnum = {
    Create: 'create',
    Delete: 'delete',
    Update: 'update'
} as const;
export type TasksPartialUpdateAnnotationsActionEnum = typeof TasksPartialUpdateAnnotationsActionEnum[keyof typeof TasksPartialUpdateAnnotationsActionEnum];
/**
 * @export
 */
export const TasksRetrieveAnnotationsActionEnum = {
    Download: 'download'
} as const;
export type TasksRetrieveAnnotationsActionEnum = typeof TasksRetrieveAnnotationsActionEnum[keyof typeof TasksRetrieveAnnotationsActionEnum];
/**
 * @export
 */
export const TasksRetrieveAnnotationsLocationEnum = {
    CloudStorage: 'cloud_storage',
    Local: 'local'
} as const;
export type TasksRetrieveAnnotationsLocationEnum = typeof TasksRetrieveAnnotationsLocationEnum[keyof typeof TasksRetrieveAnnotationsLocationEnum];
/**
 * @export
 */
export const TasksRetrieveBackupActionEnum = {
    Download: 'download'
} as const;
export type TasksRetrieveBackupActionEnum = typeof TasksRetrieveBackupActionEnum[keyof typeof TasksRetrieveBackupActionEnum];
/**
 * @export
 */
export const TasksRetrieveBackupLocationEnum = {
    CloudStorage: 'cloud_storage',
    Local: 'local'
} as const;
export type TasksRetrieveBackupLocationEnum = typeof TasksRetrieveBackupLocationEnum[keyof typeof TasksRetrieveBackupLocationEnum];
/**
 * @export
 */
export const TasksRetrieveDataQualityEnum = {
    Compressed: 'compressed',
    Original: 'original'
} as const;
export type TasksRetrieveDataQualityEnum = typeof TasksRetrieveDataQualityEnum[keyof typeof TasksRetrieveDataQualityEnum];
/**
 * @export
 */
export const TasksRetrieveDataTypeEnum = {
    Chunk: 'chunk',
    ContextImage: 'context_image',
    Frame: 'frame'
} as const;
export type TasksRetrieveDataTypeEnum = typeof TasksRetrieveDataTypeEnum[keyof typeof TasksRetrieveDataTypeEnum];
/**
 * @export
 */
export const TasksRetrieveDatasetActionEnum = {
    Download: 'download'
} as const;
export type TasksRetrieveDatasetActionEnum = typeof TasksRetrieveDatasetActionEnum[keyof typeof TasksRetrieveDatasetActionEnum];
/**
 * @export
 */
export const TasksRetrieveDatasetLocationEnum = {
    CloudStorage: 'cloud_storage',
    Local: 'local'
} as const;
export type TasksRetrieveDatasetLocationEnum = typeof TasksRetrieveDatasetLocationEnum[keyof typeof TasksRetrieveDatasetLocationEnum];
